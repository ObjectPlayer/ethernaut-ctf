import { ethers } from "hardhat";

/**
 * Execute the MagicNum exploit to deploy a contract that returns 42 (0x2a) with bytecode size <= 10 bytes
 * 
 * Usage:
 * MAGICNUM_SOLUTION_ADDRESS=0xYourExploitAddress TARGET_ADDRESS=0xYourMagicNumAddress npx hardhat run scripts/level-18-magic-num/execute-magic-num-exploit.ts --network sepolia
 */
async function main() {
  console.log("Executing MagicNum solver...");
  
  // Get the addresses from environment
  const exploitAddress = process.env.MAGICNUM_SOLUTION_ADDRESS;
  const targetAddress = process.env.TARGET_ADDRESS;
  
  if (!exploitAddress) {
    throw new Error("Environment variable MAGICNUM_SOLUTION_ADDRESS must be set");
  }
  
  if (!targetAddress) {
    throw new Error("Environment variable TARGET_ADDRESS must be set");
  }
  
  // Get the signer account
  const [signer] = await ethers.getSigners();
  console.log(`Using signer account: ${signer.address}`);
  
  // Connect to the contracts
  const magicnumSolver = await ethers.getContractAt("MagicNumSolver", exploitAddress);
  const magicnum = await ethers.getContractAt("MagicNum", targetAddress);
  
  try {
    // 1. First, deploy the minimal bytecode contract that returns 42
    console.log("Deploying minimal bytecode contract that returns 42...");
    const tx = await magicnumSolver.deploy();
    console.log("Transaction hash:", tx.hash);
    
    const receipt = await tx.wait();
    console.log("Transaction confirmed :", receipt?.hash);
    
    
    // Then call the function again but this time as a static call to get the return value
    console.log("Getting solver address from deploy function...");
    const solverAddress = await magicnumSolver.solver();
    console.log(`Deployed minimal bytecode contract at: ${solverAddress}`);
    
    // 2. Verify the contract actually returns 42 when called
    console.log("\nVerifying deployed contract returns 42...");
    const result = await magicnumSolver.verify(solverAddress);
    console.log(`Contract returns: ${result} (expected 42)`); 
    
    if (result.toString() !== '42') {
      throw new Error('Contract verification failed! It should return 42.');
    }
    
    // 3. Set the solver address in the target MagicNum contract
    console.log("\nSetting the solver in the MagicNum contract...");
    const setTx = await magicnum.setSolver(solverAddress);
    await setTx.wait();
    console.log("setSolver transaction confirmed");
    
    // 4. Verify the solver address was set correctly
    const setSolver = await magicnum.solver();
    console.log(`Solver address set in MagicNum contract: ${setSolver}`);
    
    if (setSolver.toLowerCase() !== solverAddress.toLowerCase()) {
      throw new Error('Solver address was not set correctly in the MagicNum contract.');
    }
    
    console.log("\nâœ… Success! MagicNum challenge completed.");
    console.log("The deployed solver contract is only 10 bytes in size and correctly returns 42.");
  } catch (error) {
    console.error("Error executing MagicNum exploit:", error);
    throw error;
  }
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
